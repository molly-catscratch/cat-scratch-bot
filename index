// ============================================
// PRODUCTION SLACK BOT - BEST PRACTICES VERSION
// Built according to official Slack/Bolt.js documentation
// Version: 4.0
// ============================================

const { App, LogLevel } = require('@slack/bolt');
const schedule = require('node-schedule');
const fs = require('fs').promises;
const path = require('path');

// ============================================
// APP INITIALIZATION - Per Bolt.js Best Practices
// ============================================

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  
  // Socket Mode Configuration (recommended for development)
  socketMode: true,
  appToken: process.env.SLACK_APP_TOKEN,
  
  // Development settings
  logLevel: process.env.NODE_ENV === 'production' ? LogLevel.INFO : LogLevel.DEBUG,
  
  // Custom settings
  customRoutes: [
    {
      path: '/health',
      method: ['GET'],
      handler: (req, res) => {
        res.writeHead(200);
        res.end('OK');
      }
    }
  ],
  
  // Process events even if they originate from this app
  ignoreSelf: false,
  
  // Extend context with custom properties
  extendedErrorHandler: false,
  
  // Development mode features
  developerMode: process.env.NODE_ENV !== 'production'
});

// ============================================
// GLOBAL MIDDLEWARE - Error Handling & Logging
// ============================================

// Log all incoming requests in development
if (process.env.NODE_ENV !== 'production') {
  app.use(async ({ next, context, logger }) => {
    logger.debug('Incoming request:', context);
    await next();
  });
}

// ============================================
// DATA STORAGE & STATE MANAGEMENT
// ============================================

const dataStore = {
  polls: new Map(),
  scheduledMessages: new Map(),
  activeJobs: new Map(),
  userSessions: new Map()
};

// ============================================
// UTILITY FUNCTIONS
// ============================================

const utils = {
  generateId: () => `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
  
  formatDate: (date) => {
    return new Intl.DateTimeFormat('en-US', {
      dateStyle: 'medium',
      timeStyle: 'short'
    }).format(new Date(date));
  },
  
  // Acknowledgment helper with timeout protection
  safeAck: async (ack, response = null) => {
    try {
      if (response) {
        await ack(response);
      } else {
        await ack();
      }
    } catch (error) {
      console.error('Acknowledgment failed:', error);
    }
  }
};

// ============================================
// POLL TEMPLATES
// ============================================

const POLL_TEMPLATES = {
  yes_no: {
    name: "Yes/No",
    options: ["Yes", "No"]
  },
  rating: {
    name: "1-5 Rating",
    options: ["1", "2", "3", "4", "5"]
  },
  satisfaction: {
    name: "Satisfaction",
    options: ["Very Satisfied", "Satisfied", "Neutral", "Dissatisfied", "Very Dissatisfied"]
  },
  custom: {
    name: "Custom",
    options: []
  }
};

// ============================================
// VIEW BUILDERS - Following Block Kit Best Practices
// ============================================

class ViewBuilder {
  
  // Main Dashboard - Entry Point
  static mainDashboard() {
    return {
      type: 'modal',
      callback_id: 'main_dashboard',
      title: {
        type: 'plain_text',
        text: 'Dashboard'
      },
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'üöÄ Welcome to Bot Dashboard'
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*üìä Poll Management*'
          },
          accessory: {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Create Poll'
            },
            action_id: 'action_create_poll',
            value: 'create_poll'
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*‚è∞ Message Scheduling*'
          },
          accessory: {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'Schedule Message'
            },
            action_id: 'action_schedule_message',
            value: 'schedule_message'
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*üìã View & Manage*'
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'Active Polls'
              },
              action_id: 'action_view_polls',
              value: 'view_polls'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'Scheduled Messages'
              },
              action_id: 'action_view_messages',
              value: 'view_messages'
            }
          ]
        }
      ]
    };
  }
  
  // Poll Creator View
  static pollCreator(metadata = {}) {
    const template = metadata.template || 'custom';
    const blocks = [
      {
        type: 'input',
        block_id: 'poll_question_block',
        label: {
          type: 'plain_text',
          text: 'Poll Question'
        },
        element: {
          type: 'plain_text_input',
          action_id: 'poll_question_input',
          placeholder: {
            type: 'plain_text',
            text: 'What would you like to ask?'
          },
          initial_value: metadata.question || ''
        }
      },
      {
        type: 'input',
        block_id: 'poll_channel_block',
        label: {
          type: 'plain_text',
          text: 'Channel'
        },
        element: {
          type: 'conversations_select',
          action_id: 'poll_channel_select',
          placeholder: {
            type: 'plain_text',
            text: 'Select channel'
          },
          response_url_enabled: true,
          default_to_current_conversation: true
        }
      },
      {
        type: 'section',
        block_id: 'poll_template_block',
        text: {
          type: 'mrkdwn',
          text: '*Template:*'
        },
        accessory: {
          type: 'static_select',
          action_id: 'poll_template_select',
          placeholder: {
            type: 'plain_text',
            text: 'Choose template'
          },
          initial_option: {
            text: {
              type: 'plain_text',
              text: POLL_TEMPLATES[template].name
            },
            value: template
          },
          options: Object.entries(POLL_TEMPLATES).map(([key, val]) => ({
            text: {
              type: 'plain_text',
              text: val.name
            },
            value: key
          }))
        }
      }
    ];
    
    // Add custom options if template is custom
    if (template === 'custom') {
      const numOptions = Math.max(2, Math.min(5, (metadata.options || []).length + 1));
      for (let i = 0; i < numOptions; i++) {
        blocks.push({
          type: 'input',
          block_id: `poll_option_${i}`,
          label: {
            type: 'plain_text',
            text: `Option ${i + 1}`
          },
          element: {
            type: 'plain_text_input',
            action_id: `poll_option_input_${i}`,
            placeholder: {
              type: 'plain_text',
              text: 'Enter option'
            },
            initial_value: metadata.options?.[i] || ''
          },
          optional: i >= 2
        });
      }
    }
    
    // Settings
    blocks.push({
      type: 'section',
      block_id: 'poll_settings_block',
      text: {
        type: 'mrkdwn',
        text: '*Settings:*'
      },
      accessory: {
        type: 'checkboxes',
        action_id: 'poll_settings_checkboxes',
        options: [
          {
            text: {
              type: 'plain_text',
              text: 'Allow multiple choices'
            },
            value: 'multiple'
          },
          {
            text: {
              type: 'plain_text',
              text: 'Anonymous voting'
            },
            value: 'anonymous'
          }
        ]
      }
    });
    
    return {
      type: 'modal',
      callback_id: 'poll_creator_submit',
      private_metadata: JSON.stringify(metadata),
      title: {
        type: 'plain_text',
        text: 'Create Poll'
      },
      submit: {
        type: 'plain_text',
        text: 'Create'
      },
      close: {
        type: 'plain_text',
        text: 'Cancel'
      },
      blocks
    };
  }
  
  // Message Scheduler View
  static messageScheduler(metadata = {}) {
    const isEdit = !!metadata.messageId;
    const scheduleType = metadata.scheduleType || 'one_time';
    
    const blocks = [
      {
        type: 'input',
        block_id: 'msg_channel_block',
        label: {
          type: 'plain_text',
          text: 'Channel'
        },
        element: {
          type: 'conversations_select',
          action_id: 'msg_channel_select',
          placeholder: {
            type: 'plain_text',
            text: 'Select channel'
          },
          initial_conversation: metadata.channel,
          response_url_enabled: true
        }
      },
      {
        type: 'input',
        block_id: 'msg_content_block',
        label: {
          type: 'plain_text',
          text: 'Message'
        },
        element: {
          type: 'plain_text_input',
          action_id: 'msg_content_input',
          multiline: true,
          placeholder: {
            type: 'plain_text',
            text: 'Enter your message'
          },
          initial_value: metadata.message || ''
        }
      },
      {
        type: 'section',
        block_id: 'msg_type_block',
        text: {
          type: 'mrkdwn',
          text: '*Schedule Type:*'
        },
        accessory: {
          type: 'radio_buttons',
          action_id: 'msg_type_radio',
          initial_option: {
            text: {
              type: 'plain_text',
              text: scheduleType === 'recurring' ? 'Recurring' : 'One-time'
            },
            value: scheduleType
          },
          options: [
            {
              text: { type: 'plain_text', text: 'One-time' },
              value: 'one_time'
            },
            {
              text: { type: 'plain_text', text: 'Recurring' },
              value: 'recurring'
            }
          ]
        }
      }
    ];
    
    // Add date picker for one-time
    if (scheduleType === 'one_time') {
      blocks.push({
        type: 'input',
        block_id: 'msg_date_block',
        label: {
          type: 'plain_text',
          text: 'Date'
        },
        element: {
          type: 'datepicker',
          action_id: 'msg_date_picker',
          initial_date: metadata.date || new Date().toISOString().split('T')[0]
        }
      });
    }
    
    // Add time picker
    blocks.push({
      type: 'input',
      block_id: 'msg_time_block',
      label: {
        type: 'plain_text',
        text: 'Time'
      },
      element: {
        type: 'timepicker',
        action_id: 'msg_time_picker',
        initial_time: metadata.time || '09:00'
      }
    });
    
    // Add frequency for recurring
    if (scheduleType === 'recurring') {
      blocks.push({
        type: 'section',
        block_id: 'msg_frequency_block',
        text: {
          type: 'mrkdwn',
          text: '*Frequency:*'
        },
        accessory: {
          type: 'static_select',
          action_id: 'msg_frequency_select',
          placeholder: {
            type: 'plain_text',
            text: 'Select frequency'
          },
          options: [
            { text: { type: 'plain_text', text: 'Daily' }, value: 'daily' },
            { text: { type: 'plain_text', text: 'Weekly' }, value: 'weekly' },
            { text: { type: 'plain_text', text: 'Monthly' }, value: 'monthly' }
          ]
        }
      });
    }
    
    return {
      type: 'modal',
      callback_id: isEdit ? 'message_edit_submit' : 'message_schedule_submit',
      private_metadata: JSON.stringify(metadata),
      title: {
        type: 'plain_text',
        text: isEdit ? 'Edit Message' : 'Schedule Message'
      },
      submit: {
        type: 'plain_text',
        text: isEdit ? 'Update' : 'Schedule'
      },
      close: {
        type: 'plain_text',
        text: 'Cancel'
      },
      blocks
    };
  }
  
  // List Views
  static listView(type, userId) {
    const blocks = [];
    
    if (type === 'polls') {
      const polls = Array.from(dataStore.polls.values())
        .filter(p => p.creator === userId && p.status === 'active');
      
      blocks.push({
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üìä Active Polls'
        }
      });
      
      if (polls.length === 0) {
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '_No active polls_'
          }
        });
      } else {
        polls.forEach(poll => {
          blocks.push({
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*${poll.question}*\n<#${poll.channel}> ‚Ä¢ ${Object.keys(poll.votes || {}).length} votes`
            },
            accessory: {
              type: 'overflow',
              action_id: `poll_overflow_${poll.id}`,
              options: [
                {
                  text: { type: 'plain_text', text: 'Close Poll' },
                  value: `close_poll_${poll.id}`
                },
                {
                  text: { type: 'plain_text', text: 'Delete' },
                  value: `delete_poll_${poll.id}`
                }
              ]
            }
          });
        });
      }
    } else if (type === 'messages') {
      const messages = Array.from(dataStore.scheduledMessages.values())
        .filter(m => m.userId === userId);
      
      blocks.push({
        type: 'header',
        text: {
          type: 'plain_text',
          text: '‚è∞ Scheduled Messages'
        }
      });
      
      if (messages.length === 0) {
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '_No scheduled messages_'
          }
        });
      } else {
        messages.forEach(msg => {
          const schedule = msg.scheduleType === 'recurring' ? 
            `Recurring ${msg.frequency}` : 
            `${msg.date} at ${msg.time}`;
          
          blocks.push({
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*<#${msg.channel}>*\n${schedule}\n"${msg.message.substring(0, 50)}..."`
            },
            accessory: {
              type: 'overflow',
              action_id: `msg_overflow_${msg.id}`,
              options: [
                {
                  text: { type: 'plain_text', text: 'Edit' },
                  value: `edit_msg_${msg.id}`
                },
                {
                  text: { type: 'plain_text', text: 'Delete' },
                  value: `delete_msg_${msg.id}`
                },
                {
                  text: { type: 'plain_text', text: 'Send Now' },
                  value: `send_msg_${msg.id}`
                }
              ]
            }
          });
        });
      }
    }
    
    // Add navigation
    blocks.push({
      type: 'divider'
    });
    blocks.push({
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: '‚Üê Back'
          },
          action_id: 'action_back_to_dashboard',
          value: 'back'
        },
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: type === 'polls' ? 'New Poll' : 'New Message'
          },
          style: 'primary',
          action_id: type === 'polls' ? 'action_create_poll' : 'action_schedule_message',
          value: 'create'
        }
      ]
    });
    
    return {
      type: 'modal',
      callback_id: `${type}_list`,
      title: {
        type: 'plain_text',
        text: type === 'polls' ? 'Polls' : 'Messages'
      },
      blocks
    };
  }
}

// ============================================
// SLASH COMMAND HANDLER
// ============================================

app.command('/bot', async ({ command, ack, client, logger }) => {
  try {
    // Acknowledge within 3 seconds
    await ack();
    
    // Open modal
    const result = await client.views.open({
      trigger_id: command.trigger_id,
      view: ViewBuilder.mainDashboard()
    });
    
    logger.info(`Dashboard opened for user ${command.user_id}`);
  } catch (error) {
    logger.error('Error handling /bot command:', error);
  }
});

// ============================================
// ACTION HANDLERS - Following Bolt.js Patterns
// ============================================

// Dashboard Navigation Actions
app.action('action_create_poll', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.pollCreator()
    });
  } catch (error) {
    logger.error('Error opening poll creator:', error);
  }
});

app.action('action_schedule_message', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.messageScheduler()
    });
  } catch (error) {
    logger.error('Error opening scheduler:', error);
  }
});

app.action('action_view_polls', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.listView('polls', body.user.id)
    });
  } catch (error) {
    logger.error('Error viewing polls:', error);
  }
});

app.action('action_view_messages', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.listView('messages', body.user.id)
    });
  } catch (error) {
    logger.error('Error viewing messages:', error);
  }
});

app.action('action_back_to_dashboard', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.mainDashboard()
    });
  } catch (error) {
    logger.error('Error returning to dashboard:', error);
  }
});

// Poll Template Selection
app.action('poll_template_select', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    const template = body.actions[0].selected_option.value;
    const metadata = JSON.parse(body.view.private_metadata || '{}');
    metadata.template = template;
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.pollCreator(metadata)
    });
  } catch (error) {
    logger.error('Error updating template:', error);
  }
});

// Message Type Selection
app.action('msg_type_radio', async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    const scheduleType = body.actions[0].selected_option.value;
    const metadata = JSON.parse(body.view.private_metadata || '{}');
    metadata.scheduleType = scheduleType;
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash,
      view: ViewBuilder.messageScheduler(metadata)
    });
  } catch (error) {
    logger.error('Error updating schedule type:', error);
  }
});

// Overflow Menu Actions - Using Regex Pattern
app.action(/^(poll|msg)_overflow_.*/, async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    const selectedOption = body.actions[0].selected_option;
    const [action, type, id] = selectedOption.value.split('_');
    
    if (action === 'close' && type === 'poll') {
      const poll = dataStore.polls.get(id);
      if (poll) {
        poll.status = 'closed';
        await postPollResults(client, poll);
      }
    } else if (action === 'delete') {
      if (type === 'poll') {
        dataStore.polls.delete(id);
      } else if (type === 'msg') {
        const job = dataStore.activeJobs.get(id);
        if (job) job.cancel();
        dataStore.activeJobs.delete(id);
        dataStore.scheduledMessages.delete(id);
      }
      
      // Update view
      await client.views.update({
        view_id: body.view.id,
        hash: body.view.hash,
        view: ViewBuilder.listView(type === 'poll' ? 'polls' : 'messages', body.user.id)
      });
    } else if (action === 'edit' && type === 'msg') {
      const msg = dataStore.scheduledMessages.get(id);
      if (msg) {
        await client.views.push({
          trigger_id: body.trigger_id,
          view: ViewBuilder.messageScheduler({
            messageId: id,
            ...msg
          })
        });
      }
    } else if (action === 'send' && type === 'msg') {
      const msg = dataStore.scheduledMessages.get(id);
      if (msg) {
        await sendMessage(client, msg);
      }
    }
  } catch (error) {
    logger.error('Error handling overflow action:', error);
  }
});

// Poll Vote Action - Using Regex
app.action(/^vote_poll_.*/, async ({ body, ack, client, logger }) => {
  try {
    await ack();
    
    const [, , pollId, optionIndex] = body.actions[0].action_id.split('_');
    const poll = dataStore.polls.get(pollId);
    
    if (!poll || poll.status !== 'active') {
      return;
    }
    
    const userId = body.user.id;
    const option = poll.options[parseInt(optionIndex)];
    
    if (!poll.votes) poll.votes = {};
    if (!poll.votes[userId]) poll.votes[userId] = [];
    
    if (poll.allowMultiple) {
      const idx = poll.votes[userId].indexOf(option);
      if (idx > -1) {
        poll.votes[userId].splice(idx, 1);
      } else {
        poll.votes[userId].push(option);
      }
    } else {
      poll.votes[userId] = [option];
    }
    
    // Update message
    await client.chat.update({
      channel: poll.channel,
      ts: poll.messageTs,
      blocks: buildPollBlocks(poll)
    });
    
    // Send ephemeral confirmation
    await client.chat.postEphemeral({
      channel: body.channel.id,
      user: userId,
      text: `‚úÖ Vote recorded!`
    });
  } catch (error) {
    logger.error('Error handling vote:', error);
  }
});

// ============================================
// VIEW SUBMISSION HANDLERS - With response_url
// ============================================

app.view('poll_creator_submit', async ({ ack, body, view, client, logger }) => {
  try {
    const values = view.state.values;
    const metadata = JSON.parse(view.private_metadata || '{}');
    
    // Validation
    const errors = {};
    
    const question = values.poll_question_block?.poll_question_input?.value;
    if (!question?.trim()) {
      errors.poll_question_block = 'Question required';
    }
    
    const channel = values.poll_channel_block?.poll_channel_select?.selected_conversation;
    if (!channel) {
      errors.poll_channel_block = 'Channel required';
    }
    
    // Get options based on template
    let options = [];
    if (metadata.template === 'custom') {
      for (let i = 0; i < 5; i++) {
        const value = values[`poll_option_${i}`]?.[`poll_option_input_${i}`]?.value;
        if (value?.trim()) options.push(value.trim());
      }
      if (options.length < 2) {
        errors.poll_option_0 = 'At least 2 options required';
      }
    } else {
      options = POLL_TEMPLATES[metadata.template].options;
    }
    
    if (Object.keys(errors).length > 0) {
      await ack({
        response_action: 'errors',
        errors
      });
      return;
    }
    
    // Create poll
    const pollId = utils.generateId();
    const settings = values.poll_settings_block?.poll_settings_checkboxes?.selected_options || [];
    
    const poll = {
      id: pollId,
      question: question.trim(),
      options,
      channel,
      creator: body.user.id,
      created: new Date().toISOString(),
      votes: {},
      status: 'active',
      allowMultiple: settings.some(s => s.value === 'multiple'),
      anonymous: settings.some(s => s.value === 'anonymous')
    };
    
    dataStore.polls.set(pollId, poll);
    
    // Close modal first
    await ack();
    
    // Post poll using response_url if available
    const response_urls = view.response_urls;
    if (response_urls && response_urls.length > 0) {
      const response_url = response_urls.find(r => r.channel_id === channel)?.response_url;
      if (response_url) {
        await fetch(response_url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            blocks: buildPollBlocks(poll),
            text: `Poll: ${question}`
          })
        });
        
        logger.info(`Poll posted via response_url: ${pollId}`);
        return;
      }
    }
    
    // Fallback to regular posting
    const result = await client.chat.postMessage({
      channel,
      blocks: buildPollBlocks(poll),
      text: `Poll: ${question}`
    });
    
    poll.messageTs = result.ts;
    logger.info(`Poll created: ${pollId}`);
    
  } catch (error) {
    logger.error('Error creating poll:', error);
    await ack({
      response_action: 'errors',
      errors: {
        poll_question_block: 'Failed to create poll'
      }
    });
  }
});

app.view('message_schedule_submit', async ({ ack, body, view, client, logger }) => {
  try {
    const values = view.state.values;
    
    // Validation
    const errors = {};
    
    const channel = values.msg_channel_block?.msg_channel_select?.selected_conversation;
    if (!channel) {
      errors.msg_channel_block = 'Channel required';
    }
    
    const message = values.msg_content_block?.msg_content_input?.value;
    if (!message?.trim()) {
      errors.msg_content_block = 'Message required';
    }
    
    if (Object.keys(errors).length > 0) {
      await ack({
        response_action: 'errors',
        errors
      });
      return;
    }
    
    // Create scheduled message
    const messageId = utils.generateId();
    const scheduleType = values.msg_type_block?.msg_type_radio?.selected_option?.value || 'one_time';
    
    const scheduledMessage = {
      id: messageId,
      userId: body.user.id,
      channel,
      message: message.trim(),
      scheduleType,
      date: values.msg_date_block?.msg_date_picker?.selected_date,
      time: values.msg_time_block?.msg_time_picker?.selected_time || '09:00',
      frequency: values.msg_frequency_block?.msg_frequency_select?.selected_option?.value,
      status: 'active',
      created: new Date().toISOString()
    };
    
    dataStore.scheduledMessages.set(messageId, scheduledMessage);
    
    // Schedule the message
    scheduleMessageJob(client, scheduledMessage);
    
    // Close modal with success
    await ack();
    
    // Send confirmation using response_url
    const response_urls = view.response_urls;
    if (response_urls && response_urls.length > 0) {
      const response_url = response_urls.find(r => r.channel_id === channel)?.response_url;
      if (response_url) {
        await fetch(response_url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: `‚úÖ Message scheduled successfully!`,
            response_type: 'ephemeral'
          })
        });
      }
    }
    
    logger.info(`Message scheduled: ${messageId}`);
    
  } catch (error) {
    logger.error('Error scheduling message:', error);
    await ack({
      response_action: 'errors',
      errors: {
        msg_content_block: 'Failed to schedule'
      }
    });
  }
});

// ============================================
// HELPER FUNCTIONS
// ============================================

function buildPollBlocks(poll) {
  const blocks = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: poll.question
      }
    }
  ];
  
  if (!poll.anonymous || poll.allowMultiple) {
    const info = [];
    if (poll.allowMultiple) info.push('Multiple choice');
    if (poll.anonymous) info.push('Anonymous');
    
    blocks.push({
      type: 'context',
      elements: [{
        type: 'mrkdwn',
        text: info.join(' ‚Ä¢ ')
      }]
    });
  }
  
  blocks.push({ type: 'divider' });
  
  // Add vote buttons
  const elements = poll.options.map((opt, idx) => {
    const votes = Object.values(poll.votes || {})
      .filter(v => v.includes(opt)).length;
    
    return {
      type: 'button',
      text: {
        type: 'plain_text',
        text: `${opt} (${votes})`
      },
      action_id: `vote_poll_${poll.id}_${idx}`,
      value: opt
    };
  });
  
  // Split into rows of 5
  for (let i = 0; i < elements.length; i += 5) {
    blocks.push({
      type: 'actions',
      elements: elements.slice(i, i + 5)
    });
  }
  
  // Footer
  blocks.push({
    type: 'context',
    elements: [{
      type: 'mrkdwn',
      text: `${Object.keys(poll.votes || {}).length} votes`
    }]
  });
  
  return blocks;
}

async function postPollResults(client, poll) {
  const results = {};
  poll.options.forEach(opt => {
    results[opt] = Object.values(poll.votes || {})
      .filter(v => v.includes(opt)).length;
  });
  
  const total = Object.keys(poll.votes || {}).length;
  const blocks = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: 'üìä Poll Results'
      }
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${poll.question}*`
      }
    },
    { type: 'divider' }
  ];
  
  Object.entries(results)
    .sort((a, b) => b[1] - a[1])
    .forEach(([option, votes]) => {
      const pct = total > 0 ? Math.round((votes / total) * 100) : 0;
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*${option}*\n${pct}% (${votes} votes)`
        }
      });
    });
  
  await client.chat.postMessage({
    channel: poll.channel,
    blocks,
    text: `Poll closed: ${poll.question}`
  });
}

function scheduleMessageJob(client, message) {
  // Cancel existing job
  const existing = dataStore.activeJobs.get(message.id);
  if (existing) existing.cancel();
  
  const [hours, minutes] = message.time.split(':').map(Number);
  
  if (message.scheduleType === 'one_time') {
    const date = new Date(message.date);
    date.setHours(hours, minutes, 0, 0);
    
    if (date > new Date()) {
      const job = schedule.scheduleJob(date, async () => {
        await sendMessage(client, message);
        message.status = 'sent';
      });
      
      dataStore.activeJobs.set(message.id, job);
    }
  } else if (message.scheduleType === 'recurring') {
    let cronPattern;
    
    if (message.frequency === 'daily') {
      cronPattern = `${minutes} ${hours} * * *`;
    } else if (message.frequency === 'weekly') {
      cronPattern = `${minutes} ${hours} * * 1`;
    } else if (message.frequency === 'monthly') {
      cronPattern = `${minutes} ${hours} 1 * *`;
    }
    
    if (cronPattern) {
      const job = schedule.scheduleJob(cronPattern, async () => {
        await sendMessage(client, message);
      });
      
      dataStore.activeJobs.set(message.id, job);
    }
  }
}

async function sendMessage(client, message) {
  try {
    await client.chat.postMessage({
      channel: message.channel,
      text: message.message
    });
  } catch (error) {
    console.error(`Failed to send message ${message.id}:`, error);
  }
}

// ============================================
// ERROR HANDLING
// ============================================

app.error(async (error) => {
  console.error('Global error:', error);
});

// ============================================
// STARTUP
// ============================================

(async () => {
  try {
    await app.start();
    console.log('‚ö°Ô∏è Bolt app is running!');
    console.log('Socket Mode:', process.env.SLACK_APP_TOKEN ? 'Enabled' : 'Disabled');
    console.log('Ready to receive commands via /bot');
  } catch (error) {
    console.error('Failed to start app:', error);
    process.exit(1);
  }
})();
