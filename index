// ================================
// CAT SCRATCH SLACK BOT - COMPLETE WORKING VERSION WITH NAVIGATION FIXES
// ================================

const { App } = require('@slack/bolt');
const express = require('express');
const cron = require('node-cron');
const fs = require('fs');
require('dotenv').config();

// ================================
// KEEP-ALIVE SERVER
// ================================
const keep_alive = express();

keep_alive.get('/', (req, res) => {
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>Cat Scratch Bot</title>
        <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f0f0f0; }
            .container { background: white; padding: 30px; border-radius: 10px; display: inline-block; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
            .status { color: #28a745; font-weight: bold; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üê± Cat Scratch Bot is Alive!</h1>
            <p class="status">Status: Running ‚úÖ</p>
            <p>Uptime: ${Math.floor(process.uptime())} seconds</p>
            <p>Time: ${new Date().toLocaleString()}</p>
            <p>Ready to handle /cat commands!</p>
            <p>Scheduled Messages: ${scheduledMessages.length}</p>
        </div>
    </body>
    </html>
  `);
});

keep_alive.get('/health', (req, res) => {
  res.json({ 
    status: 'alive',
    uptime: process.uptime(),
    timestamp: new Date().toISOString(),
    bot: 'Cat Scratch Bot',
    scheduledMessages: scheduledMessages.length,
    activeJobs: jobs.size
  });
});

keep_alive.get('/ping', (req, res) => {
  res.send('pong üèì');
});

const PORT = process.env.PORT || 3000;
keep_alive.listen(PORT, '0.0.0.0', () => {
  console.log(`üåê Keep-alive server running on port ${PORT}`);
});

// ================================
// SLACK BOT INITIALIZATION
// ================================
const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  appToken: process.env.SLACK_APP_TOKEN,
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  socketMode: true
});

// ================================
// STORAGE & STATE MANAGEMENT
// ================================
const SCHEDULE_FILE = './scheduledMessages.json';
const POLLS_FILE = './pollData.json';
let scheduledMessages = [];
const jobs = new Map();
let pollVotes = {};
const pollMessages = new Map();
let openEndedResponses = {};
const userProfileCache = new Map();
const sessionData = new Map();
const viewRegistry = new Map();

// Storage functions
function saveMessages() {
  try {
    fs.writeFileSync(SCHEDULE_FILE, JSON.stringify(scheduledMessages, null, 2));
    console.log(`üíæ Saved ${scheduledMessages.length} scheduled messages`);
  } catch (e) {
    console.error('‚ùå Save messages failed:', e);
  }
}

function savePollData() {
  try {
    const pollData = {
      votes: pollVotes,
      responses: openEndedResponses,
      messages: Array.from(pollMessages.entries()).map(([id, data]) => [id, data])
    };
    fs.writeFileSync(POLLS_FILE, JSON.stringify(pollData, null, 2));
    console.log(`üíæ Saved poll data for ${Object.keys(pollVotes).length} polls`);
  } catch (e) {
    console.error('‚ùå Save poll data failed:', e);
  }
}

function loadMessages() {
  if (fs.existsSync(SCHEDULE_FILE)) {
    try {
      const data = JSON.parse(fs.readFileSync(SCHEDULE_FILE));
      console.log(`üìÇ Loading ${data.length} messages from storage`);

      scheduledMessages = data.filter(msg => {
        if (msg.repeat && msg.repeat !== 'none') {
          return true;
        }
        const isPast = isDateTimeInPast(msg.date, msg.time);
        return !isPast;
      });

      console.log(`üìÇ Loaded ${scheduledMessages.length} valid messages after filtering`);
      if (scheduledMessages.length !== data.length) {
        saveMessages();
      }
    } catch (e) {
      console.error('‚ùå Load messages failed:', e);
      scheduledMessages = [];
    }
  }
}

function loadPollData() {
  if (fs.existsSync(POLLS_FILE)) {
    try {
      const data = JSON.parse(fs.readFileSync(POLLS_FILE));
      pollVotes = data.votes || {};
      openEndedResponses = data.responses || {};
      if (data.messages) {
        data.messages.forEach(([id, messageData]) => {
          pollMessages.set(id, messageData);
        });
      }
      console.log(`üìä Loaded poll data for ${Object.keys(pollVotes).length} polls`);
    } catch (e) {
      console.error('‚ùå Load poll data failed:', e);
      pollVotes = {};
      openEndedResponses = {};
    }
  }
}

// ================================
// UTILITIES
// ================================
const generateId = () => `msg_${Date.now()}_${Math.floor(Math.random() * 100000)}`;
const cat = () => Math.random() < 0.35 ? ` ${['‚Çç^. .^‚Çé‚üÜ', '·ìö‚Çç ^. .^‚Çé', '‡∏Ö^‚Ä¢Ôªå‚Ä¢^‡∏Ö'][Math.floor(Math.random() * 3)]}` : '';

function todayInEST() {
  return new Intl.DateTimeFormat('en-CA', { timeZone: 'America/New_York' }).format(new Date());
}

function currentTimeInEST() {
  return new Intl.DateTimeFormat('en-GB', {
    timeZone: 'America/New_York',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  }).format(new Date());
}

function formatTimeDisplay(timeStr) {
  if (!timeStr) return 'Invalid Time';
  const [hour, minute] = timeStr.split(':').map(Number);
  const period = hour >= 12 ? 'PM' : 'AM';
  const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
  return `${displayHour}:${minute.toString().padStart(2, '0')} ${period}`;
}

function formatDateDisplay(dateStr) {
  if (!dateStr) return 'Invalid Date';
  try {
    const date = new Date(dateStr + 'T00:00:00');
    return date.toLocaleDateString('en-US', { 
      weekday: 'short', 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
  } catch (e) {
    return 'Invalid Date';
  }
}

function isDateTimeInPast(dateStr, timeStr) {
  try {
    const now = new Date();
    const targetDateTime = new Date(`${dateStr}T${timeStr}:00`);
    const nowEST = new Date(now.toLocaleString("en-US", {timeZone: "America/New_York"}));
    const targetEST = new Date(targetDateTime.toLocaleString("en-US", {timeZone: "America/New_York"}));
    return targetEST <= nowEST;
  } catch (error) {
    console.error('‚ùå Timezone calculation error:', error);
    return false;
  }
}

function extractFormData(view) {
  const values = view.state.values;
  const data = {};

  // Extract basic content
  if (values.message_content?.message_text?.value) {
    data.text = values.message_content.message_text.value.trim();
  }
  if (values.message_content?.message_text?.rich_text_value) {
    data.richText = values.message_content.message_text.rich_text_value;
  }

  // Extract alert channels for help button
  if (values.alert_channels?.alert_channels_select?.selected_conversations) {
    data.alertChannels = values.alert_channels.alert_channels_select.selected_conversations;
  }

  // Extract poll data
  if (values.poll_question?.poll_question_text?.value) {
    data.text = values.poll_question.poll_question_text.value.trim();
  }
  if (values.poll_options?.poll_options_text?.value) {
    data.pollOptions = values.poll_options.poll_options_text.value.trim();
  }

  // Extract scheduling data
  if (values.target_channel?.channel_select?.selected_conversation) {
    data.targetChannel = values.target_channel.channel_select.selected_conversation;
  }
  if (values.schedule_timing?.date_picker?.selected_date) {
    data.scheduleDate = values.schedule_timing.date_picker.selected_date;
  }
  if (values.schedule_timing?.time_picker?.selected_time) {
    data.scheduleTime = values.schedule_timing.time_picker.selected_time;
  }
  if (values.repeat_options?.repeat_select?.selected_option) {
    data.repeatValue = values.repeat_options.repeat_select.selected_option.value;
    data.repeatOption = values.repeat_options.repeat_select.selected_option.text.text;
  }

  // Extract send now channel
  if (values.send_channel?.immediate_channel_select?.selected_conversation) {
    data.sendChannel = values.send_channel.immediate_channel_select.selected_conversation;
  }

  return data;
}

// ================================
// MESSAGE TEMPLATES - EXACT SPECIFICATIONS
// ================================
const templates = {
  daily_checkin: {
    title: "Daily Bandwidth Check",
    text: "How's everyone's capacity looking today?\n\nUse the reactions below to share your current workload:\nüü¢ Light schedule - Ready for new work\nüü° Manageable schedule\nüü† Schedule is full, no new work\nüî¥ Overloaded - Need help now"
  },
  help_button: {
    title: "Need Backup?",
    text: "If you're stuck or need assistance, click the button below to alert the team."
  },
  poll: "What would you like to ask the team?",
  blank: ""
};

// ================================
// MESSAGE GENERATION FUNCTIONS
// ================================
function generateMessageBlocks(type, data = {}) {
  switch (type) {
    case 'daily_checkin':
      return [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: (data.title ? `*${data.title}*\n` : '') + (data.text || templates.daily_checkin.text) + cat()
          }
        }
      ];

    case 'help_button':
      return [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: (data.title ? `*${data.title}*\n` : '') + (data.text || templates.help_button.text) + cat()
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              style: 'danger',
              text: { type: 'plain_text', text: 'üÜò Request Backup', emoji: true },
              action_id: `help_click_${data.id || 'preview'}`,
              value: JSON.stringify({
                msgId: data.id || 'preview',
                alertChannels: data.alertChannels || []
              })
            }
          ]
        }
      ];

    case 'poll':
      const pollOptions = (data.pollOptions || 'Option 1\nOption 2\nOption 3').split('\n').filter(o => o.trim());
      const blocks = [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${data.text || templates.poll}* ${cat()}`
          }
        },
        {
          type: 'divider'
        }
      ];

      const emojis = ['üçï', 'üåÆ', 'üç£', 'ü•ó', 'üçî', 'üçù', 'ü•™', 'üåØ', 'üçú', 'ü•ò'];

      pollOptions.forEach((option, index) => {
        const emoji = emojis[index % emojis.length];
        blocks.push(
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `${emoji} *${option.trim()}*`
            },
            accessory: {
              type: 'button',
              text: { type: 'plain_text', text: 'Vote', emoji: true },
              action_id: `poll_vote_${data.id || 'preview'}`,
              value: JSON.stringify({ 
                pollId: data.id || 'preview', 
                optionIndex: index, 
                option: option.trim() 
              })
            }
          },
          {
            type: 'context',
            elements: [{
              type: 'mrkdwn',
              text: '0 votes'
            }]
          }
        );
      });

      return blocks;

    case 'blank':
    default:
      if (data.richText && data.richText.elements) {
        return [
          {
            type: 'rich_text',
            elements: data.richText.elements
          }
        ];
      } else {
        return [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: (data.title ? `*${data.title}*\n` : '') + (data.text || 'Your blank message content') + cat()
            }
          }
        ];
      }
  }
}

// ================================
// MESSAGE SENDING FUNCTIONS
// ================================
async function sendMessage(msg) {
  try {
    if (!msg.channel) {
      console.error('‚ùå No channel specified for message');
      return false;
    }

    // Verify channel access
    try {
      await app.client.conversations.info({ channel: msg.channel });
    } catch (error) {
      console.error(`‚ùå Channel access failed: ${error.data?.error}`);
      return false;
    }

    if (msg.type === 'daily_checkin') {
      const messageText = (msg.title ? `*${msg.title}*\n` : '') + (msg.text || templates.daily_checkin.text) + cat();

      const result = await app.client.chat.postMessage({
        channel: msg.channel,
        text: messageText
      });

      // Add reactions for capacity check
      if (result.ok && result.ts) {
        const reactions = ['green_heart', 'yellow_heart', 'orange_heart', 'red_circle'];
        for (const reaction of reactions) {
          try {
            await new Promise(resolve => setTimeout(resolve, 100));
            await app.client.reactions.add({ 
              channel: msg.channel, 
              timestamp: result.ts, 
              name: reaction 
            });
          } catch (e) {
            console.error(`‚ùå Reaction failed: ${e.data?.error}`);
          }
        }
      }
    } else if (msg.type === 'help_button') {
      const blocks = generateMessageBlocks('help_button', msg);
      await app.client.chat.postMessage({
        channel: msg.channel,
        text: 'Help button message',
        blocks
      });
    } else if (msg.type === 'poll') {
      const pollId = msg.id;
      const blocks = generateMessageBlocks('poll', msg);

      // Initialize poll data
      if (!pollVotes[pollId]) {
        pollVotes[pollId] = {};
        pollMessages.set(pollId, {
          channel: msg.channel,
          options: (msg.pollOptions || '').split('\n').filter(o => o.trim()),
          question: msg.text || templates.poll
        });
        savePollData();
      }

      await app.client.chat.postMessage({
        channel: msg.channel,
        text: 'Poll message',
        blocks
      });
    } else {
      // Blank message
      const blocks = generateMessageBlocks('blank', msg);
      await app.client.chat.postMessage({
        channel: msg.channel,
        text: 'Blank message',
        blocks
      });
    }

    console.log(`‚úÖ ${msg.type} message sent to ${msg.channel}`);
    return true;
  } catch (e) {
    console.error('‚ùå Send failed:', e);
    return false;
  }
}

// ================================
// SCHEDULING FUNCTIONS
// ================================
function scheduleJob(msg) {
  if (jobs.has(msg.id)) {
    try {
      jobs.get(msg.id).destroy();
    } catch (e) {
      console.error(`‚ùå Error destroying job: ${e.message}`);
    }
    jobs.delete(msg.id);
  }

  const [hh, mm] = msg.time.split(':').map(Number);
  let cronExpr;

  if (msg.repeat === 'daily') {
    cronExpr = `${mm} ${hh} * * *`;
  } else if (msg.repeat === 'weekly') {
    const day = new Date(msg.date + 'T00:00:00').getDay();
    cronExpr = `${mm} ${hh} * * ${day}`;
  } else if (msg.repeat === 'monthly') {
    const day = msg.date.split('-')[2];
    cronExpr = `${mm} ${hh} ${day} * *`;
  } else {
    const [y, mon, d] = msg.date.split('-');
    cronExpr = `${mm} ${hh} ${d} ${parseInt(mon)} *`;
  }

  console.log(`üïê Creating job for ${msg.id}: ${cronExpr} (${msg.repeat})`);

  try {
    const job = cron.schedule(cronExpr, async () => {
      console.log(`‚ö° Executing scheduled ${msg.type} message: ${msg.id}`);

      try {
        const success = await sendMessage(msg);

        if (success) {
          console.log(`‚úÖ Scheduled message executed successfully: ${msg.id}`);
        } else {
          console.error(`‚ùå Scheduled message execution failed: ${msg.id}`);
        }

        if (msg.repeat === 'none') {
          console.log(`üóëÔ∏è Removing one-time message: ${msg.id}`);
          const messageIndex = scheduledMessages.findIndex(m => m.id === msg.id);
          if (messageIndex >= 0) {
            scheduledMessages.splice(messageIndex, 1);
            saveMessages();
          }
          try {
            job.destroy();
            jobs.delete(msg.id);
          } catch (cleanupError) {
            console.error(`‚ùå Error cleaning up job: ${cleanupError}`);
          }
        }
      } catch (executionError) {
        console.error(`‚ùå Error in job execution for ${msg.id}:`, executionError);
      }
    }, {
      timezone: 'America/New_York',
      scheduled: true
    });

    if (job) {
      jobs.set(msg.id, job);
      console.log(`‚úÖ Job created successfully for ${msg.id}`);
      return true;
    } else {
      console.error(`‚ùå Failed to create job for ${msg.id}`);
      return false;
    }
  } catch (error) {
    console.error(`‚ùå Error creating scheduled job for ${msg.id}:`, error);
    return false;
  }
}

function reRegisterAllJobs() {
  console.log('üîÑ Re-registering all scheduled jobs...');
  let successCount = 0;
  let failCount = 0;
  let skippedCount = 0;

  scheduledMessages.forEach((msg) => {
    const shouldSchedule = msg.repeat !== 'none' || !isDateTimeInPast(msg.date, msg.time);
    if (shouldSchedule) {
      const success = scheduleJob(msg);
      if (success) {
        successCount++;
      } else {
        failCount++;
      }
    } else {
      skippedCount++;
    }
  });

  console.log(`üìä Job registration complete: ${successCount} success, ${failCount} failed, ${skippedCount} skipped`);
}

// ================================
// MODAL BUILDERS - SLACK API COMPLIANT
// ================================
class ModalBuilder {
  static createMainMenu(userId = null) {
    return {
      type: 'modal',
      callback_id: 'main_menu',
      title: {
        type: 'plain_text',
        text: 'Cat Scratch Bot',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Close',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Welcome ${userId ? `<@${userId}>` : 'to Cat Scratch'}!*\n\nChoose a message type to get started:${cat()}`
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Daily Check-In',
                emoji: true
              },
              style: 'primary',
              value: 'daily_checkin',
              action_id: 'select_daily_checkin'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üÜò Help Button',
                emoji: true
              },
              style: 'danger',
              value: 'help_button',
              action_id: 'select_help_button'
            }
          ]
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Polls',
                emoji: true
              },
              value: 'poll',
              action_id: 'select_poll'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìù Blank',
                emoji: true
              },
              value: 'blank',
              action_id: 'select_blank'
            }
          ]
        },
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìÖ Manage Message Schedule',
                emoji: true
              },
              style: 'primary',
              value: 'manage_messages',
              action_id: 'manage_scheduled_messages'
            }
          ]
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: '*Tip:* All messages can be scheduled for one-time or recurring delivery'
            }
          ]
        }
      ]
    };
  }

  // PAGE 1: Template/Textbox for all message types
  static createSetupModal(type, data = {}) {
    const titles = {
      daily_checkin: 'üìä Daily Check-In Setup',
      help_button: 'üÜò Help Button Setup',
      poll: 'üìä Poll Setup',
      blank: 'üìù Blank Message Setup'
    };

    const labels = {
      daily_checkin: 'üìä Daily Check-In Message',
      help_button: 'üÜò Help Request Message',
      poll: '‚ùì Poll Question',
      blank: 'üìù Message Content'
    };

    if (type === 'poll') {
      return this.createPollSetupModal(data);
    }

    const initialValue = data.text || (templates[type] ? templates[type].text || templates[type] : '');

    return {
      type: 'modal',
      callback_id: `${type}_setup`,
      title: {
        type: 'plain_text',
        text: titles[type],
        emoji: true
      },
      submit: {
        type: 'plain_text',
        text: 'Next ‚Üí',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Page 1: Template/Textbox*${cat()}\n\nCustomize your ${type.replace('_', ' ')} message:`
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'input',
          block_id: 'message_content',
          element: type === 'blank' ? {
            type: 'rich_text_input',
            action_id: 'message_text'
          } : {
            type: 'plain_text_input',
            multiline: true,
            action_id: 'message_text',
            initial_value: initialValue,
            placeholder: {
              type: 'plain_text',
              text: `Enter your ${type.replace('_', ' ')} message...`
            }
          },
          label: {
            type: 'plain_text',
            text: labels[type],
            emoji: true
          }
        },
        ...(type === 'help_button' ? [{
          type: 'input',
          block_id: 'alert_channels',
          element: {
            type: 'multi_conversations_select',
            action_id: 'alert_channels_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select channels to alert...',
              emoji: true
            },
            filter: {
              include: ['public', 'private']
            },
            ...(data.alertChannels ? { initial_conversations: data.alertChannels } : {})
          },
          label: {
            type: 'plain_text',
            text: 'Alert Channels',
            emoji: true
          },
          optional: false
        }] : []),
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: '‚Üê Back to Menu',
                emoji: true
              },
              action_id: 'back_to_main_menu',
              value: 'back'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Daily Check-In',
                emoji: true
              },
              value: 'daily_checkin',
              action_id: 'nav_daily_checkin'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üÜò Help',
                emoji: true
              },
              value: 'help_button',
              action_id: 'nav_help_button'
            }
          ]
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Poll',
                emoji: true
              },
              value: 'poll',
              action_id: 'nav_poll'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìù Blank',
                emoji: true
              },
              value: 'blank',
              action_id: 'nav_blank'
            }
          ]
        }
      ]
    };
  }

  static createPollSetupModal(data = {}) {
    return {
      type: 'modal',
      callback_id: 'poll_setup',
      title: {
        type: 'plain_text',
        text: 'üìä Poll Setup',
        emoji: true
      },
      submit: {
        type: 'plain_text',
        text: 'Next ‚Üí',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Page 1: Template/Textbox*${cat()}\n\nCreate your poll:`
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'input',
          block_id: 'poll_question',
          element: {
            type: 'plain_text_input',
            multiline: true,
            action_id: 'poll_question_text',
            initial_value: data.text || templates.poll,
            placeholder: {
              type: 'plain_text',
              text: 'Enter your poll question...'
            }
          },
          label: {
            type: 'plain_text',
            text: '‚ùì Poll Question',
            emoji: true
          }
        },
        {
          type: 'input',
          block_id: 'poll_options',
          element: {
            type: 'plain_text_input',
            multiline: true,
            action_id: 'poll_options_text',
            initial_value: data.pollOptions || 'Option 1\nOption 2\nOption 3',
            placeholder: {
              type: 'plain_text',
              text: 'Enter each option on a new line...'
            }
          },
          label: {
            type: 'plain_text',
            text: 'üìù Poll Options (one per line)',
            emoji: true
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: '‚Üê Back to Menu',
                emoji: true
              },
              action_id: 'back_to_main_menu',
              value: 'back'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Daily Check-In',
                emoji: true
              },
              value: 'daily_checkin',
              action_id: 'nav_daily_checkin'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üÜò Help',
                emoji: true
              },
              value: 'help_button',
              action_id: 'nav_help_button'
            }
          ]
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Poll',
                emoji: true
              },
              value: 'poll',
              action_id: 'nav_poll'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìù Blank',
                emoji: true
              },
              value: 'blank',
              action_id: 'nav_blank'
            }
          ]
        }
      ]
    };
  }

  // PAGE 2: Message Preview with Post Now/Schedule Later - FIXED
  static createPreviewModal(type, data = {}) {
    const typeLabels = {
      daily_checkin: 'üìä Daily Check-In',
      help_button: 'üÜò Help Button',
      poll: 'üìä Poll',
      blank: 'üìù Blank Message'
    };

    return {
      type: 'modal',
      callback_id: 'message_preview',
      title: {
        type: 'plain_text',
        text: 'üëÄ Message Preview',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Page 2: Message Preview*${cat()}\n\nPreview your ${typeLabels[type] || 'message'}:`
          }
        },
        {
          type: 'divider'
        },
        ...this.generatePreviewBlocks(type, data),
        {
          type: 'divider'
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*Post now? Yes / No Schedule for later*'
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: '‚úÖ Post Now (Yes)',
                emoji: true
              },
              style: 'primary',
              value: type, // CRITICAL: Message type as value
              action_id: 'post_now'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìÖ Schedule for Later (No)',
                emoji: true
              },
              value: type, // CRITICAL: Message type as value
              action_id: 'schedule_later'
            }
          ]
        },
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: '‚Üê Edit Message',
                emoji: true
              },
              value: type,
              action_id: 'back_to_setup'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üè† Main Menu',
                emoji: true
              },
              action_id: 'back_to_main_menu',
              value: 'back'
            }
          ]
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Daily Check-In',
                emoji: true
              },
              value: 'daily_checkin',
              action_id: 'nav_daily_checkin'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üÜò Help',
                emoji: true
              },
              value: 'help_button',
              action_id: 'nav_help_button'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Poll',
                emoji: true
              },
              value: 'poll',
              action_id: 'nav_poll'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìù Blank',
                emoji: true
              },
              value: 'blank',
              action_id: 'nav_blank'
            }
          ]
        }
      ]
    };
  }

  // PAGE 3: Scheduler
  static createSchedulerModal(type, data = {}) {
    const typeLabels = {
      daily_checkin: 'üìä Daily Check-In',
      help_button: 'üÜò Help Button',
      poll: 'üìä Poll',
      blank: 'üìù Blank Message'
    };

    return {
      type: 'modal',
      callback_id: 'message_scheduler',
      submit: {
        type: 'plain_text',
        text: 'üöÄ Schedule Message',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      title: {
        type: 'plain_text',
        text: 'üìÖ Schedule Message',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Page 3: Scheduler*${cat()}\n\nSchedule your ${typeLabels[type] || 'message'}:`
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'input',
          block_id: 'target_channel',
          element: {
            type: 'conversations_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select a channel',
              emoji: true
            },
            action_id: 'channel_select',
            filter: {
              include: ['public', 'private']
            },
            ...(data.targetChannel ? { initial_conversation: data.targetChannel } : {})
          },
          label: {
            type: 'plain_text',
            text: 'üìç Select Channel to post to',
            emoji: true
          }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*Select time (EST) or post now:*'
          }
        },
        {
          type: 'actions',
          block_id: 'schedule_timing',
          elements: [
            {
              type: 'datepicker',
              initial_date: data.scheduleDate || todayInEST(),
              placeholder: {
                type: 'plain_text',
                text: 'Select date'
              },
              action_id: 'date_picker'
            },
            {
              type: 'timepicker',
              initial_time: data.scheduleTime || currentTimeInEST(),
              placeholder: {
                type: 'plain_text',
                text: 'Select time (EST)'
              },
              action_id: 'time_picker'
            }
          ]
        },
        {
          type: 'input',
          block_id: 'repeat_options',
          element: {
            type: 'static_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select repeat option'
            },
            options: [
              { text: { type: 'plain_text', text: 'One-time only' }, value: 'none' },
              { text: { type: 'plain_text', text: 'Daily' }, value: 'daily' },
              { text: { type: 'plain_text', text: 'Weekly' }, value: 'weekly' },
              { text: { type: 'plain_text', text: 'Monthly' }, value: 'monthly' }
            ],
            action_id: 'repeat_select',
            initial_option: { text: { type: 'plain_text', text: 'One-time only' }, value: 'none' }
          },
          label: {
            type: 'plain_text',
            text: 'üîÑ Repeat options (Daily Weekly Monthly or custom)',
            emoji: true
          },
          optional: true
        },
        {
          type: 'context',
          elements: [{
            type: 'mrkdwn',
            text: 'üïê All times are in Eastern Time (EST). Messages will be sent at the scheduled time.'
          }]
        },
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: '‚Üê Back to Preview',
                emoji: true
              },
              action_id: 'back_to_preview',
              value: type
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üè† Main Menu',
                emoji: true
              },
              action_id: 'back_to_main_menu',
              value: 'back'
            }
          ]
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Daily Check-In',
                emoji: true
              },
              value: 'daily_checkin',
              action_id: 'nav_daily_checkin'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üÜò Help',
                emoji: true
              },
              value: 'help_button',
              action_id: 'nav_help_button'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìä Poll',
                emoji: true
              },
              value: 'poll',
              action_id: 'nav_poll'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìù Blank',
                emoji: true
              },
              value: 'blank',
              action_id: 'nav_blank'
            }
          ]
        }
      ]
    };
  }

  // Post Now Modal
  static createPostNowModal(type, data = {}) {
    const typeLabels = {
      daily_checkin: 'üìä Daily Check-In',
      help_button: 'üÜò Help Button',
      poll: 'üìä Poll',
      blank: 'üìù Blank Message'
    };

    return {
      type: 'modal',
      callback_id: 'post_now_confirm',
      title: {
        type: 'plain_text',
        text: 'üöÄ Post Now',
        emoji: true
      },
      submit: {
        type: 'plain_text',
        text: 'üöÄ Post Now',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Ready to post your ${typeLabels[type] || 'message'} now!*${cat()}\n\nSelect a channel:`
          }
        },
        {
          type: 'input',
          block_id: 'send_channel',
          element: {
            type: 'conversations_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select a channel',
              emoji: true
            },
            action_id: 'immediate_channel_select',
            filter: {
              include: ['public', 'private']
            }
          },
          label: {
            type: 'plain_text',
            text: 'üìç Post to Channel',
            emoji: true
          }
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: 'üí° This will post your message immediately to the selected channel'
            }
          ]
        },
        {
          type: 'divider'
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: '‚Üê Back to Preview',
                emoji: true
              },
              action_id: 'back_to_preview',
              value: type
            }
          ]
        }
      ]
    };
  }

  static createMessageManagerModal(scheduledMessages = []) {
    const blocks = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*üìÖ Manage Schedule Messages*${cat()}\n\n${scheduledMessages.length > 0 ? `You have *${scheduledMessages.length}* scheduled message${scheduledMessages.length !== 1 ? 's' : ''}` : 'No scheduled messages yet'}`
        }
      },
      {
        type: 'divider'
      }
    ];

    if (scheduledMessages.length === 0) {
      blocks.push(
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: 'üîÑ *No scheduled messages yet*\n\nUse the button below to create your first scheduled message!'
          }
        },
        {
          type: 'actions',
          elements: [{
            type: 'button',
            text: { type: 'plain_text', text: '‚ú® Create First Message', emoji: true },
            style: 'primary',
            action_id: 'create_first_message',
            value: 'create_first'
          }]
        }
      );
    } else {
      scheduledMessages.forEach((msg, index) => {
        const nextRun = msg.repeat === 'none' ? 
          `${formatDateDisplay(msg.date)} at ${formatTimeDisplay(msg.time)}` : 
          `${msg.repeat} at ${formatTimeDisplay(msg.time)}`;

        const actionId = `manage_message_${msg.id}`;

        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${msg.title || (msg.type ? msg.type.replace('_', ' ') : 'Message')}*\nüìÖ ${nextRun}\nüìç <#${msg.channel}>`
          },
          accessory: {
            type: 'overflow',
            action_id: actionId,
            options: [
              { 
                text: { type: 'plain_text', text: '‚úèÔ∏è Edit Message' }, 
                value: `edit_${msg.id}` 
              },
              { 
                text: { type: 'plain_text', text: 'üóëÔ∏è Delete Message' }, 
                value: `delete_${msg.id}` 
              }
            ]
          }
        });
      });
    }

    blocks.push(
      { type: 'divider' },
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: { type: 'plain_text', text: 'üè† Back to Menu', emoji: true },
            action_id: 'back_to_main_menu',
            value: 'back'
          },
          {
            type: 'button',
            text: { type: 'plain_text', text: '‚ûï Create New Message', emoji: true },
            style: 'primary',
            action_id: 'create_new_message',
            value: 'new'
          }
        ]
      }
    );

    return {
      type: 'modal',
      callback_id: 'message_manager',
      title: { type: 'plain_text', text: 'Manage Schedule Messages', emoji: true },
      close: { type: 'plain_text', text: 'Close', emoji: true },
      blocks
    };
  }

  static generatePreviewBlocks(type, data = {}) {
    switch (type) {
      case 'daily_checkin':
        return [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `üìã *Preview:*\n\n${data.text || templates.daily_checkin.text}`
            }
          },
          {
            type: 'context',
            elements: [{
              type: 'mrkdwn',
              text: '‚Üì These reactions will be automatically added ‚Üì'
            }]
          },
          {
            type: 'section',
            fields: [
              { type: 'mrkdwn', text: '*üü¢ Light schedule*\nReady for new work' },
              { type: 'mrkdwn', text: '*üü° Manageable*\nCurrently balanced' },
              { type: 'mrkdwn', text: '*üü† Schedule full*\nNo new work please' },
              { type: 'mrkdwn', text: '*üî¥ Overloaded*\nNeed help now' }
            ]
          }
        ];

      case 'help_button':
        return [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `üÜò *Preview:*\n\n${data.text || templates.help_button.text}`
            }
          },
          {
            type: 'actions',
            elements: [{
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üÜò Request Backup',
                emoji: true
              },
              style: 'danger',
              action_id: 'preview_help_button',
              value: 'preview_only'
            }]
          },
          {
            type: 'context',
            elements: [{
              type: 'mrkdwn',
              text: `Alert will be sent to: ${data.alertChannels && data.alertChannels.length > 0 ? data.alertChannels.map(c => `<#${c}>`).join(', ') : '(selected channels)'}`
            }]
          }
        ];

      case 'poll':
        const pollOptions = (data.pollOptions || 'Option 1\nOption 2\nOption 3').split('\n').filter(o => o.trim());
        const previewBlocks = [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `üìä *Preview:*\n\n*${data.text || templates.poll}*`
            }
          },
          {
            type: 'divider'
          }
        ];

        const emojis = ['üçï', 'üåÆ', 'üç£', 'ü•ó', 'üçî', 'üçù', 'ü•™', 'üåØ', 'üçú', 'ü•ò'];

        pollOptions.forEach((option, index) => {
          const emoji = emojis[index % emojis.length];
          previewBlocks.push({
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `${emoji} *${option.trim()}*`
            },
            accessory: {
              type: 'button',
              text: {
                type: 'plain_text',
                emoji: true,
                text: 'Vote'
              },
              value: `vote_${index}`,
              action_id: 'preview_vote'
            }
          });
        });

        return previewBlocks;

      case 'blank':
      default:
        if (data.richText && data.richText.elements) {
          return [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: 'üìù *Preview:*'
              }
            },
            {
              type: 'rich_text',
              elements: data.richText.elements
            }
          ];
        } else {
          return [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `üìù *Preview:*\n\n${data.text || 'Your blank message content will appear here'}`
              }
            }
          ];
        }
    }
  }
}

// ================================
// SLASH COMMAND HANDLER
// ================================
app.command('/cat', async ({ command, ack, client }) => {
  await ack();

  try {
    console.log(`üê± /cat command received from user ${command.user_id}`);

    const modal = ModalBuilder.createMainMenu(command.user_id);
    const result = await client.views.open({
      trigger_id: command.trigger_id,
      view: modal
    });

    if (result.ok && result.view && result.view.id) {
      viewRegistry.set(command.user_id, {
        viewId: result.view.id,
        hash: result.view.hash
      });
    }

    console.log('‚úÖ Main menu modal opened successfully');
  } catch (error) {
    console.error('‚ùå Error opening modal:', error);
  }
});

// ================================
// INTERACTIVE COMPONENT HANDLERS - SLACK API COMPLIANT
// ================================

// Main menu selections (block_action ‚Üí views.update)
app.action('select_daily_checkin', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createSetupModal('daily_checkin');
    sessionData.set(body.user.id, { type: 'daily_checkin', data: {} });
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Daily check-in setup opened');
  } catch (error) {
    console.error('‚ùå Error opening daily check-in setup:', error);
  }
});

app.action('select_help_button', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createSetupModal('help_button');
    sessionData.set(body.user.id, { type: 'help_button', data: {} });
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Help button setup opened');
  } catch (error) {
    console.error('‚ùå Error opening help button setup:', error);
  }
});

app.action('select_poll', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createSetupModal('poll');
    sessionData.set(body.user.id, { type: 'poll', data: {} });
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Poll setup opened');
  } catch (error) {
    console.error('‚ùå Error opening poll setup:', error);
  }
});

app.action('select_blank', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createSetupModal('blank');
    sessionData.set(body.user.id, { type: 'blank', data: {} });
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Blank message setup opened');
  } catch (error) {
    console.error('‚ùå Error opening blank message setup:', error);
  }
});

// Navigation handlers with data preservation (block_action ‚Üí views.update)
const handleNavigation = async (targetType, { ack, body, client }) => {
  await ack();
  try {
    const currentSession = sessionData.get(body.user.id) || {};
    const modal = ModalBuilder.createSetupModal(targetType, currentSession.data || {});
    sessionData.set(body.user.id, { 
      type: targetType, 
      data: currentSession.data || {} 
    });
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log(`‚úÖ Navigation to ${targetType} (data preserved)`);
  } catch (error) {
    console.error(`‚ùå Error navigating to ${targetType}:`, error);
  }
};

app.action('nav_daily_checkin', (params) => handleNavigation('daily_checkin', params));
app.action('nav_help_button', (params) => handleNavigation('help_button', params));
app.action('nav_poll', (params) => handleNavigation('poll', params));
app.action('nav_blank', (params) => handleNavigation('blank', params));

// Back navigation (block_action ‚Üí views.update)
app.action('back_to_main_menu', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createMainMenu(body.user.id);
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Returned to main menu');
  } catch (error) {
    console.error('‚ùå Error returning to main menu:', error);
  }
});

app.action('back_to_preview', async ({ ack, body, client }) => {
  await ack();
  try {
    const messageType = body.actions[0].value;
    const sessionInfo = sessionData.get(body.user.id) || {};
    const modal = ModalBuilder.createPreviewModal(messageType, sessionInfo.data || {});
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log(`‚úÖ Returned to preview for ${messageType}`);
  } catch (error) {
    console.error('‚ùå Error returning to preview:', error);
  }
});

app.action('back_to_setup', async ({ ack, body, client }) => {
  await ack();
  try {
    const messageType = body.actions[0].value;
    const sessionInfo = sessionData.get(body.user.id) || {};
    const modal = ModalBuilder.createSetupModal(messageType, sessionInfo.data || {});
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log(`‚úÖ Returned to setup for ${messageType}`);
  } catch (error) {
    console.error('‚ùå Error returning to setup:', error);
  }
});

// Post Now and Schedule Later buttons (block_action ‚Üí views.update) - FIXED
app.action('post_now', async ({ ack, body, client }) => {
  await ack();
  try {
    console.log('Post Now button clicked');
    const messageType = body.actions[0].value;
    const sessionInfo = sessionData.get(body.user.id) || {};
    console.log(`Session info for post now:`, sessionInfo);
    
    const modal = ModalBuilder.createPostNowModal(messageType, sessionInfo.data || {});
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log(`‚úÖ Post Now modal opened for ${messageType}`);
  } catch (error) {
    console.error('‚ùå Error opening post now modal:', error);
  }
});

app.action('schedule_later', async ({ ack, body, client }) => {
  await ack();
  try {
    console.log('Schedule Later button clicked');
    const messageType = body.actions[0].value;
    const sessionInfo = sessionData.get(body.user.id) || {};
    console.log(`Session info for schedule later:`, sessionInfo);
    
    const modal = ModalBuilder.createSchedulerModal(messageType, sessionInfo.data || {});
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log(`‚úÖ Scheduler modal opened for ${messageType}`);
  } catch (error) {
    console.error('‚ùå Error going to scheduler:', error);
  }
});

// Manage scheduled messages (block_action ‚Üí views.update) - FIXED
app.action('manage_scheduled_messages', async ({ ack, body, client }) => {
  await ack();
  try {
    console.log('Message Manager button clicked');
    const modal = ModalBuilder.createMessageManagerModal(scheduledMessages);
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Message management opened');
  } catch (error) {
    console.error('‚ùå Error accessing message management:', error);
  }
});

// Create new/first message handlers
app.action('create_new_message', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createMainMenu(body.user.id);
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Returned to main menu to create new message');
  } catch (error) {
    console.error('‚ùå Error returning to main menu:', error);
  }
});

app.action('create_first_message', async ({ ack, body, client }) => {
  await ack();
  try {
    const modal = ModalBuilder.createMainMenu(body.user.id);
    await client.views.update({
      view_id: body.view.id,
      view: modal
    });
    console.log('‚úÖ Returned to main menu to create first message');
  } catch (error) {
    console.error('‚ùå Error returning to main menu:', error);
  }
});

// Message management overflow actions
app.action(/^manage_message_.+/, async ({ ack, body, client, action }) => {
  await ack();
  try {
    const selectedOption = action.selected_option;
    if (!selectedOption || !selectedOption.value) {
      console.log('‚ùå No selected option found in overflow action');
      return;
    }

    const actionValue = selectedOption.value;
    const underscoreIndex = actionValue.indexOf('_');
    
    if (underscoreIndex === -1) {
      console.log('‚ùå Invalid action format:', actionValue);
      return;
    }

    const actionType = actionValue.substring(0, underscoreIndex);
    const msgId = actionValue.substring(underscoreIndex + 1);

    console.log(`üîß Managing message: ${actionType} for ${msgId}`);

    if (actionType === 'delete') {
      const messageIndex = scheduledMessages.findIndex(msg => msg.id === msgId);
      if (messageIndex >= 0) {
        const deletedMsg = scheduledMessages.splice(messageIndex, 1)[0];

        if (jobs.has(msgId)) {
          try {
            jobs.get(msgId).destroy();
            jobs.delete(msgId);
          } catch (jobError) {
            console.error(`‚ùå Error destroying job ${msgId}:`, jobError);
          }
        }

        saveMessages();
        console.log(`üóëÔ∏è Deleted message: ${msgId}`);

        const modal = ModalBuilder.createMessageManagerModal(scheduledMessages);
        await client.views.update({
          view_id: body.view.id,
          view: modal
        });

        await client.chat.postEphemeral({
          channel: body.channel?.id || body.user.id,
          user: body.user.id,
          text: `‚úÖ Message deleted successfully! üóëÔ∏è${cat()}`
        });
      }
    } else if (actionType === 'edit') {
      await client.chat.postEphemeral({
        channel: body.channel?.id || body.user.id,
        user: body.user.id,
        text: `‚úèÔ∏è Edit functionality coming soon! For now, you can delete and recreate the message.${cat()}`
      });
    }
  } catch (error) {
    console.error('‚ùå Error managing message:', error);
    await client.chat.postEphemeral({
      channel: body.channel?.id || body.user.id,
      user: body.user.id,
      text: '‚ùå Error managing message. Please try again.'
    });
  }
});

// Preview button handlers (non-functional)
app.action('preview_help_button', async ({ ack }) => {
  await ack();
  console.log('üëÜ Preview help button clicked (non-functional)');
});

app.action('preview_vote', async ({ ack }) => {
  await ack();
  console.log('üëÜ Preview vote button clicked (non-functional)');
});

// ================================
// MODAL SUBMISSION HANDLERS - SLACK API COMPLIANT (view_submission ‚Üí response_action)
// ================================

// PAGE 1 ‚Üí PAGE 2: Setup to Preview (view_submission ‚Üí response_action) - FIXED
app.view('daily_checkin_setup', async ({ ack, body }) => {
  const formData = extractFormData(body.view);
  console.log('Daily check-in setup submission:', formData);

  const errors = {};
  if (!formData.text || formData.text.trim() === '') {
    errors.message_content = 'Message content is required';
  }

  if (Object.keys(errors).length > 0) {
    await ack({ response_action: 'errors', errors: errors });
    return;
  }

  sessionData.set(body.user.id, { type: 'daily_checkin', data: formData });
  const previewModal = ModalBuilder.createPreviewModal('daily_checkin', formData);
  
  await ack({ response_action: 'update', view: previewModal });
  console.log('‚úÖ Daily check-in: Page 1 ‚Üí Page 2');
});

app.view('help_button_setup', async ({ ack, body }) => {
  const formData = extractFormData(body.view);
  console.log('Help button setup submission:', formData);

  const errors = {};
  if (!formData.text || formData.text.trim() === '') {
    errors.message_content = 'Message content is required';
  }
  if (!formData.alertChannels || formData.alertChannels.length === 0) {
    errors.alert_channels = 'At least one alert channel is required';
  }

  if (Object.keys(errors).length > 0) {
    await ack({ response_action: 'errors', errors: errors });
    return;
  }

  sessionData.set(body.user.id, { type: 'help_button', data: formData });
  const previewModal = ModalBuilder.createPreviewModal('help_button', formData);
  
  await ack({ response_action: 'update', view: previewModal });
  console.log('‚úÖ Help button: Page 1 ‚Üí Page 2');
});

app.view('poll_setup', async ({ ack, body }) => {
  const formData = extractFormData(body.view);
  console.log('Poll setup submission:', formData);

  const errors = {};
  if (!formData.text || formData.text.trim() === '') {
    errors.poll_question = 'Poll question is required';
  }
  if (!formData.pollOptions || formData.pollOptions.trim() === '') {
    errors.poll_options = 'Poll options are required';
  } else {
    const options = formData.pollOptions.split('\n').filter(o => o.trim());
    if (options.length < 2) {
      errors.poll_options = 'At least 2 poll options are required';
    }
  }

  if (Object.keys(errors).length > 0) {
    await ack({ response_action: 'errors', errors: errors });
    return;
  }

  sessionData.set(body.user.id, { type: 'poll', data: formData });
  const previewModal = ModalBuilder.createPreviewModal('poll', formData);
  
  await ack({ response_action: 'update', view: previewModal });
  console.log('‚úÖ Poll: Page 1 ‚Üí Page 2');
});

app.view('blank_setup', async ({ ack, body }) => {
  const formData = extractFormData(body.view);
  console.log('Blank setup submission:', formData);

  const errors = {};
  if (!formData.text && !formData.richText) {
    errors.message_content = 'Message content is required';
  }

  if (Object.keys(errors).length > 0) {
    await ack({ response_action: 'errors', errors: errors });
    return;
  }

  sessionData.set(body.user.id, { type: 'blank', data: formData });
  const previewModal = ModalBuilder.createPreviewModal('blank', formData);
  
  await ack({ response_action: 'update', view: previewModal });
  console.log('‚úÖ Blank: Page 1 ‚Üí Page 2');
});

// Post Now submission (view_submission ‚Üí response_action)
app.view('post_now_confirm', async ({ ack, body, client }) => {
  const formData = extractFormData(body.view);
  const sessionInfo = sessionData.get(body.user.id) || {};

  const errors = {};
  if (!formData.sendChannel) {
    errors.send_channel = 'Please select a channel';
  }
  if (!sessionInfo.data || !sessionInfo.type) {
    errors.send_channel = 'Session data not found. Please try again.';
  }

  if (Object.keys(errors).length > 0) {
    await ack({ response_action: 'errors', errors: errors });
    return;
  }

  await ack({ response_action: 'clear' });

  const messageData = {
    ...sessionInfo.data,
    type: sessionInfo.type,
    channel: formData.sendChannel,
    id: generateId()
  };

  const success = await sendMessage(messageData);
  const statusMessage = success 
    ? `‚úÖ ${sessionInfo.type.replace('_', ' ')} posted to <#${formData.sendChannel}>!${cat()}`
    : '‚ùå Failed to post message. Please try again.';

  await client.chat.postEphemeral({
    channel: body.user.id,
    user: body.user.id,
    text: statusMessage
  });

  sessionData.delete(body.user.id);
  console.log(`‚úÖ Message posted: ${sessionInfo.type}`);
});

// Scheduler submission (view_submission ‚Üí response_action)
app.view('message_scheduler', async ({ ack, body, client }) => {
  const formData = extractFormData(body.view);
  const sessionInfo = sessionData.get(body.user.id) || {};

  const messageData = { ...sessionInfo.data, ...formData };
  messageData.type = sessionInfo.type;
  messageData.id = generateId();
  messageData.date = formData.scheduleDate || todayInEST();
  messageData.time = formData.scheduleTime || currentTimeInEST();
  messageData.repeat = formData.repeatValue || 'none';
  messageData.channel = formData.targetChannel;

  const errors = {};
  if (!messageData.targetChannel) {
    errors.target_channel = 'Please select a channel';
  }
  if (messageData.type === 'help_button' && (!messageData.alertChannels || messageData.alertChannels.length === 0)) {
    errors.target_channel = 'Please configure alert channels in message setup';
  }
  if (messageData.repeat === 'none' && isDateTimeInPast(messageData.date, messageData.time)) {
    errors.schedule_timing = 'Cannot schedule messages in the past';
  }

  if (Object.keys(errors).length > 0) {
    await ack({ response_action: 'errors', errors: errors });
    return;
  }

  await ack({ response_action: 'clear' });

  scheduledMessages.push(messageData);
  saveMessages();

  const jobSuccess = scheduleJob(messageData);
  const statusMessage = jobSuccess
    ? `‚úÖ ${messageData.type.replace('_', ' ')} scheduled for <#${messageData.channel}> at ${formatTimeDisplay(messageData.time)}${cat()}`
    : '‚ùå Failed to schedule message. Please try again.';

  await client.chat.postEphemeral({
    channel: body.user.id,
    user: body.user.id,
    text: statusMessage
  });

  sessionData.delete(body.user.id);
  console.log(`‚úÖ Message scheduled: ${messageData.type}`);
});

// ================================
// POLL VOTING HANDLERS
// ================================
app.action(/^poll_vote_.+/, async ({ ack, body, client, action }) => {
  await ack();

  try {
    const actionData = JSON.parse(action.value);
    const { pollId, optionIndex, option } = actionData;
    const userId = body.user.id;

    if (pollId === 'preview') {
      console.log('üëÜ Preview poll vote clicked (non-functional)');
      return;
    }

    if (!pollVotes[pollId]) {
      pollVotes[pollId] = {};
    }

    if (pollVotes[pollId][userId] === optionIndex) {
      delete pollVotes[pollId][userId];
    } else {
      pollVotes[pollId][userId] = optionIndex;
    }

    savePollData();

    const pollData = pollMessages.get(pollId);
    if (pollData) {
      const voteCounts = {};
      Object.values(pollVotes[pollId]).forEach(voteIndex => {
        voteCounts[voteIndex] = (voteCounts[voteIndex] || 0) + 1;
      });

      const blocks = generateMessageBlocks('poll', {
        id: pollId,
        text: pollData.question,
        pollOptions: pollData.options.join('\n')
      });

      blocks.forEach((block, blockIndex) => {
        if (block.type === 'context' && blockIndex > 2) {
          const optionIndex = Math.floor((blockIndex - 3) / 2);
          const voteCount = voteCounts[optionIndex] || 0;
          block.elements[0].text = `${voteCount} vote${voteCount !== 1 ? 's' : ''}`;
        }
      });

      await client.chat.update({
        channel: pollData.channel,
        ts: body.message.ts,
        text: 'Poll message',
        blocks
      });
    }

    console.log(`üó≥Ô∏è Vote recorded: User ${userId} voted for option ${optionIndex} in poll ${pollId}`);

  } catch (error) {
    console.error('‚ùå Error handling poll vote:', error);
  }
});

// ================================
// HELP BUTTON HANDLERS
// ================================
app.action(/^help_click_.+/, async ({ ack, body, client, action }) => {
  await ack();

  try {
    const actionData = JSON.parse(action.value);
    const alertChannels = actionData.alertChannels || [];
    const user = body.user.id;
    const channel = body.channel.id;

    if (actionData.msgId === 'preview') {
      console.log('üëÜ Preview help button clicked (non-functional)');
      return;
    }

    if (alertChannels.length === 0) {
      await client.chat.postEphemeral({
        channel,
        user,
        text: '‚ùå No alert channels configured for this help button.'
      });
      return;
    }

    let successCount = 0;
    for (const alertChannel of alertChannels) {
      try {
        await client.chat.postMessage({
          channel: alertChannel,
          text: `üÜò <@${user}> needs backup in <#${channel}> ${cat()}`
        });
        successCount++;
      } catch (e) {
        console.error(`‚ùå Alert failed for channel ${alertChannel}:`, e);
      }
    }

    await client.chat.postEphemeral({
      channel,
      user,
      text: `‚úÖ Backup request sent to ${successCount}/${alertChannels.length} channels.`
    });

    if (successCount > 0) {
      await client.chat.postMessage({
        channel,
        text: `üÜò <@${user}> has requested backup assistance ${cat()}`
      });
    }

    console.log(`üÜò Help request: User ${user} alerted ${successCount} channels`);

  } catch (error) {
    console.error('‚ùå Error handling help button:', error);
  }
});

// ================================
// DEBUG COMMANDS
// ================================
app.command('/cat-debug', async ({ ack, body, client }) => {
  await ack();
  const channelId = body.channel_id;
  const userId = body.user_id;

  try {
    const debugInfo = `üê± *Cat Scratch Bot Debug Info*${cat()}\n\n` +
      `*Status:* Running ‚úÖ\n` +
      `*Uptime:* ${Math.floor(process.uptime())} seconds\n` +
      `*Scheduled Messages:* ${scheduledMessages.length}\n` +
      `*Active Jobs:* ${jobs.size}\n` +
      `*Poll Data:* ${Object.keys(pollVotes).length} polls\n` +
      `*Memory Usage:* ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB\n` +
      `*Current EST Time:* ${currentTimeInEST()}\n` +
      `*View Registry:* ${viewRegistry.size} active views\n` +
      `*Session Data:* ${sessionData.size} active sessions`;

    await client.chat.postEphemeral({
      channel: channelId,
      user: userId,
      text: debugInfo
    });

    console.log(`üîß Debug info requested by user ${userId}`);
  } catch (error) {
    console.error('‚ùå Debug command failed:', error);
    await client.chat.postEphemeral({
      channel: channelId,
      user: userId,
      text: '‚ùå Debug failed - check console logs'
    });
  }
});

// ================================
// ERROR HANDLING & DEBUG LOGGING
// ================================
app.error(async (error) => {
  console.error('üî• Slack App Error:', error);
});

// Debug logging for troubleshooting - REMOVE AFTER TESTING
app.view(/.*/, async ({ body }) => {
  console.log(`üîç VIEW SUBMISSION: ${body.view.callback_id} by user ${body.user.id}`);
  // Don't ack here - let specific handlers do it
});

app.action(/.*/, async ({ body, action }) => {
  console.log(`üîç ACTION: ${action.action_id} (value: ${action.value}) by user ${body.user.id}`);
  // Don't ack here - let specific handlers do it
});

// Cleanup expired messages every hour
cron.schedule('0 * * * *', () => {
  console.log('üßπ Running hourly cleanup...');

  const beforeCount = scheduledMessages.length;
  scheduledMessages = scheduledMessages.filter(msg => {
    if (msg.repeat !== 'none') return true;
    const isPast = isDateTimeInPast(msg.date, msg.time);
    if (isPast && jobs.has(msg.id)) {
      try {
        jobs.get(msg.id).destroy();
        jobs.delete(msg.id);
        console.log(`üóëÔ∏è Cleaned up expired job: ${msg.id}`);
      } catch (e) {
        console.error(`‚ùå Error cleaning up job ${msg.id}:`, e);
      }
    }
    return !isPast;
  });

  if (scheduledMessages.length !== beforeCount) {
    saveMessages();
    console.log(`üßπ Removed ${beforeCount - scheduledMessages.length} expired messages`);
  }

  viewRegistry.clear();
  console.log('üßπ Cleared view registry');
}, { timezone: 'America/New_York' });

// Memory management
setInterval(() => {
  const used = process.memoryUsage();
  const mb = (bytes) => Math.round(bytes / 1024 / 1024);
  console.log(`üíæ Memory usage: ${mb(used.heapUsed)}MB heap, ${mb(used.rss)}MB RSS`);

  if (mb(used.heapUsed) > 200) {
    userProfileCache.clear();
    console.log('üßπ Cleared user profile cache due to high memory usage');
  }
}, 600000);

// ================================
// STARTUP SEQUENCE
// ================================
(async () => {
  try {
    loadMessages();
    loadPollData();
    await app.start();

    console.log('üê± Cat Scratch Slack Bot is running in Socket Mode!');
    console.log('ü§ñ Ready to handle /cat commands');
    console.log('üì° Socket Mode: Enabled (no Request URLs needed)');
    console.log(`üìÇ Loaded ${scheduledMessages.length} scheduled messages`);
    console.log(`üìä Loaded poll data for ${Object.keys(pollVotes).length} polls`);

    reRegisterAllJobs();

    console.log(`‚ö° Active jobs: ${jobs.size}`);
    console.log(`üïê Current EST time: ${currentTimeInEST()}`);
    
    const domain = process.env.REPLIT_DEV_DOMAIN || process.env.REPLIT_DOMAINS;
    if (domain) {
      console.log(`üîó Cron job URL: https://${domain}/ping`);
    }
    console.log('üîó Health check available at: /ping and /health');
    console.log('üì± Bot features:');
    console.log('   ‚Ä¢ Daily Check-ins with reactions');
    console.log('   ‚Ä¢ Help Buttons with alerts');
    console.log('   ‚Ä¢ Interactive Polls with voting');
    console.log('   ‚Ä¢ Blank Messages');
    console.log('   ‚Ä¢ Full scheduling system');
    console.log('   ‚Ä¢ Message management');
    console.log('‚úÖ All systems ready! Use /cat to start.');

  } catch (error) {
    console.error('‚ùå Failed to start the app:', error);
    process.exit(1);
  }
})();

// ================================
// GRACEFUL SHUTDOWN
// ================================
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully...');
  saveMessages();
  savePollData();
  jobs.forEach((job, id) => {
    try {
      job.destroy();
      console.log(`üßπ Destroyed job: ${id}`);
    } catch (e) {
      console.log(`‚ùå Could not destroy job ${id}: ${e.message}`);
    }
  });
  console.log('üëã Shutdown complete');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT received, shutting down gracefully...');
  saveMessages();
  savePollData();
  jobs.forEach((job, id) => {
    try {
      job.destroy();
      console.log(`üßπ Destroyed job: ${id}`);
    } catch (e) {
      console.log(`‚ùå Could not destroy job ${id}: ${e.message}`);
    }
  });
  console.log('üëã Shutdown complete');
  process.exit(0);
});

module.exports = { app, ModalBuilder };
