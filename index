// ============================================
// COMPLETE ENHANCED SLACK BOT SYSTEM
// Version: 2.0
// Features: Polls, Scheduled Messages, Fixed Navigation
// ============================================

const { App } = require('@slack/bolt');
const schedule = require('node-schedule');
const fs = require('fs').promises;
const path = require('path');

// ============================================
// INITIALIZATION
// ============================================

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  appToken: process.env.SLACK_APP_TOKEN,
  socketMode: true,
});

// ============================================
// DATA STORAGE (In-Memory)
// Replace with database in production
// ============================================

const polls = new Map();
const scheduledMessages = new Map();
const activeJobs = new Map();
const userPreferences = new Map();

// ============================================
// UTILITY FUNCTIONS
// ============================================

const generateId = () => `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

const formatDate = (date) => {
  return new Date(date).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};

const todayInEST = () => {
  const now = new Date();
  const estOffset = -5; // EST is UTC-5
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  return new Date(utc + (3600000 * estOffset));
};

// ============================================
// POLL TEMPLATES
// ============================================

const POLL_TEMPLATES = {
  yes_no: {
    name: "Yes/No",
    description: "Simple binary choice",
    options: ["Yes", "No"]
  },
  rating: {
    name: "1-5 Rating",
    description: "Rate on a scale of 1-5",
    options: ["1 - Poor", "2 - Fair", "3 - Good", "4 - Very Good", "5 - Excellent"]
  },
  meeting_time: {
    name: "Meeting Times",
    description: "Choose meeting availability",
    options: ["Morning (9-11am)", "Midday (11am-1pm)", "Afternoon (1-3pm)", "Late Afternoon (3-5pm)"]
  },
  custom: {
    name: "Custom",
    description: "Create your own options",
    options: []
  }
};

// ============================================
// MAIN MODAL BUILDER CLASS
// ============================================

class ModalBuilder {
  // Main Dashboard
  static mainMenu(trigger_id) {
    return {
      trigger_id,
      view: {
        type: 'modal',
        callback_id: 'main_menu',
        title: {
          type: 'plain_text',
          text: 'Bot Dashboard',
          emoji: true
        },
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: 'üöÄ Welcome to Your Bot Dashboard',
              emoji: true
            }
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*Hello <@${trigger_id}>!*\nWhat would you like to do today?`
            }
          },
          {
            type: 'divider'
          },
          // Poll Section
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '*üìä Polls & Surveys*\nCreate and manage interactive polls'
            }
          },
          {
            type: 'actions',
            elements: [
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'üìä Create Poll',
                  emoji: true
                },
                style: 'primary',
                action_id: 'open_poll_creator'
              },
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'üìã View Active Polls',
                  emoji: true
                },
                action_id: 'view_active_polls'
              },
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'üìà Poll History',
                  emoji: true
                },
                action_id: 'view_poll_history'
              }
            ]
          },
          {
            type: 'divider'
          },
          // Scheduled Messages Section
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '*‚è∞ Scheduled Messages*\nAutomate your communications'
            }
          },
          {
            type: 'actions',
            elements: [
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: '‚è∞ Schedule Message',
                  emoji: true
                },
                style: 'primary',
                action_id: 'open_scheduler'
              },
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'üìÖ View Scheduled',
                  emoji: true
                },
                action_id: 'view_scheduled'
              },
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'üìù Templates',
                  emoji: true
                },
                action_id: 'message_templates'
              }
            ]
          },
          {
            type: 'divider'
          },
          // Settings Section
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: '*‚öôÔ∏è Settings & Help*'
            }
          },
          {
            type: 'actions',
            elements: [
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: '‚öôÔ∏è Preferences',
                  emoji: true
                },
                action_id: 'open_preferences'
              },
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: '‚ùì Help',
                  emoji: true
                },
                action_id: 'show_help'
              }
            ]
          },
          {
            type: 'context',
            elements: [
              {
                type: 'mrkdwn',
                text: `Last login: ${formatDate(new Date())} | Version 2.0`
              }
            ]
          }
        ]
      }
    };
  }

  // Poll Creator with Templates
  static pollCreator(metadata = {}) {
    const selectedTemplate = metadata.template || 'custom';
    const templateData = POLL_TEMPLATES[selectedTemplate];
    
    return {
      type: 'modal',
      callback_id: 'poll_creator',
      private_metadata: JSON.stringify(metadata),
      title: {
        type: 'plain_text',
        text: 'Create New Poll',
        emoji: true
      },
      submit: {
        type: 'plain_text',
        text: 'Create Poll',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'üìä Poll Configuration',
            emoji: true
          }
        },
        // Template Selection
        {
          type: 'section',
          block_id: 'template_select',
          text: {
            type: 'mrkdwn',
            text: '*Choose a template:*'
          },
          accessory: {
            type: 'static_select',
            action_id: 'select_template',
            placeholder: {
              type: 'plain_text',
              text: 'Select template'
            },
            initial_option: {
              text: {
                type: 'plain_text',
                text: templateData.name
              },
              value: selectedTemplate
            },
            options: Object.entries(POLL_TEMPLATES).map(([key, template]) => ({
              text: {
                type: 'plain_text',
                text: template.name
              },
              value: key
            }))
          }
        },
        // Poll Question
        {
          type: 'input',
          block_id: 'poll_question',
          label: {
            type: 'plain_text',
            text: 'Poll Question',
            emoji: true
          },
          element: {
            type: 'plain_text_input',
            action_id: 'question_input',
            placeholder: {
              type: 'plain_text',
              text: 'What would you like to ask?'
            },
            initial_value: metadata.question || '',
            max_length: 200
          }
        },
        // Channel Selection
        {
          type: 'input',
          block_id: 'poll_channel',
          label: {
            type: 'plain_text',
            text: 'Post to Channel',
            emoji: true
          },
          element: {
            type: 'channels_select',
            action_id: 'channel_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select a channel'
            }
          }
        },
        // Poll Options (Dynamic based on template)
        ...this.generatePollOptionsBlocks(selectedTemplate, metadata.options),
        // Advanced Settings Section
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*‚öôÔ∏è Advanced Settings*'
          }
        },
        // Multiple Choice Toggle
        {
          type: 'section',
          block_id: 'multiple_choice',
          text: {
            type: 'mrkdwn',
            text: 'Allow multiple selections'
          },
          accessory: {
            type: 'checkboxes',
            action_id: 'multiple_toggle',
            options: [
              {
                text: {
                  type: 'plain_text',
                  text: 'Enable'
                },
                value: 'multiple_enabled'
              }
            ],
            initial_options: metadata.allowMultiple ? [{
              text: {
                type: 'plain_text',
                text: 'Enable'
              },
              value: 'multiple_enabled'
            }] : []
          }
        },
        // Anonymous Voting
        {
          type: 'section',
          block_id: 'anonymous_voting',
          text: {
            type: 'mrkdwn',
            text: 'Anonymous voting'
          },
          accessory: {
            type: 'checkboxes',
            action_id: 'anonymous_toggle',
            options: [
              {
                text: {
                  type: 'plain_text',
                  text: 'Enable'
              },
              value: 'anonymous_enabled'
            }
          }
        },
        // Time Limit
        {
          type: 'section',
          block_id: 'time_limit',
          text: {
            type: 'mrkdwn',
            text: 'Set time limit for poll'
          },
          accessory: {
            type: 'static_select',
            action_id: 'time_select',
            placeholder: {
              type: 'plain_text',
              text: 'No time limit'
            },
            options: [
              { text: { type: 'plain_text', text: 'No limit' }, value: 'none' },
              { text: { type: 'plain_text', text: '15 minutes' }, value: '15' },
              { text: { type: 'plain_text', text: '30 minutes' }, value: '30' },
              { text: { type: 'plain_text', text: '1 hour' }, value: '60' },
              { text: { type: 'plain_text', text: '2 hours' }, value: '120' },
              { text: { type: 'plain_text', text: '1 day' }, value: '1440' }
            ]
          }
        },
        // Preview Section
        {
          type: 'divider'
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*üì± Preview:*\n' + this.generatePollPreview(metadata)
          }
        }
      ]
    };
  }

  static generatePollOptionsBlocks(template, customOptions = []) {
    const blocks = [];
    const options = template === 'custom' ? customOptions : POLL_TEMPLATES[template].options;
    
    if (template === 'custom') {
      // For custom polls, allow editing options
      for (let i = 0; i < Math.max(2, options.length); i++) {
        blocks.push({
          type: 'input',
          block_id: `option_${i}`,
          label: {
            type: 'plain_text',
            text: `Option ${i + 1}`
          },
          element: {
            type: 'plain_text_input',
            action_id: `option_input_${i}`,
            placeholder: {
              type: 'plain_text',
              text: 'Enter option text'
            },
            initial_value: options[i] || '',
            max_length: 75
          },
          optional: i >= 2
        });
      }
      
      // Add button to add more options
      blocks.push({
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: {
              type: 'plain_text',
              text: '‚ûï Add Option',
              emoji: true
            },
            action_id: 'add_poll_option'
          }
        ]
      });
    } else {
      // For template polls, show read-only preview
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: '*Poll Options:*\n' + options.map((opt, i) => `${i + 1}. ${opt}`).join('\n')
        }
      });
    }
    
    return blocks;
  }

  static generatePollPreview(metadata) {
    const question = metadata.question || '_Your question will appear here_';
    const template = metadata.template || 'custom';
    const options = template === 'custom' ? 
      (metadata.options || ['Option 1', 'Option 2']) : 
      POLL_TEMPLATES[template].options;
    
    let preview = `*${question}*\n\n`;
    options.forEach((opt, i) => {
      if (opt) {
        preview += `${i + 1}Ô∏è‚É£ ${opt}\n`;
      }
    });
    
    if (metadata.allowMultiple) {
      preview += '\n_‚úì Multiple selections allowed_';
    }
    if (metadata.anonymous) {
      preview += '\n_üîí Anonymous voting enabled_';
    }
    
    return preview;
  }

  // Scheduled Message Creator
  static messageScheduler(metadata = {}) {
    const isEdit = metadata.messageId ? true : false;
    
    return {
      type: 'modal',
      callback_id: isEdit ? 'edit_scheduled_message' : 'schedule_message',
      private_metadata: JSON.stringify(metadata),
      title: {
        type: 'plain_text',
        text: isEdit ? 'Edit Scheduled Message' : 'Schedule Message',
        emoji: true
      },
      submit: {
        type: 'plain_text',
        text: isEdit ? 'Update' : 'Schedule',
        emoji: true
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: isEdit ? '‚úèÔ∏è Edit Scheduled Message' : '‚è∞ Schedule New Message',
            emoji: true
          }
        },
        // Channel Selection
        {
          type: 'input',
          block_id: 'message_channel',
          label: {
            type: 'plain_text',
            text: 'Select Channel',
            emoji: true
          },
          element: {
            type: 'channels_select',
            action_id: 'channel_select',
            placeholder: {
              type: 'plain_text',
              text: 'Choose a channel'
            },
            initial_channel: metadata.channel
          }
        },
        // Message Content
        {
          type: 'input',
          block_id: 'message_content',
          label: {
            type: 'plain_text',
            text: 'Message Content',
            emoji: true
          },
          element: {
            type: 'plain_text_input',
            action_id: 'message_input',
            multiline: true,
            placeholder: {
              type: 'plain_text',
              text: 'Enter your message here...'
            },
            initial_value: metadata.message || '',
            max_length: 3000
          }
        },
        // Schedule Type Selection
        {
          type: 'section',
          block_id: 'schedule_type',
          text: {
            type: 'mrkdwn',
            text: '*Schedule Type:*'
          },
          accessory: {
            type: 'radio_buttons',
            action_id: 'schedule_type_select',
            initial_option: {
              text: {
                type: 'plain_text',
                text: metadata.scheduleType === 'recurring' ? 'Recurring' : 'One-time'
              },
              value: metadata.scheduleType || 'one_time'
            },
            options: [
              {
                text: {
                  type: 'plain_text',
                  text: 'One-time'
                },
                value: 'one_time'
              },
              {
                text: {
                  type: 'plain_text',
                  text: 'Recurring'
                },
                value: 'recurring'
              }
            ]
          }
        },
        // Date Selection (for one-time)
        {
          type: 'input',
          block_id: 'schedule_date',
          label: {
            type: 'plain_text',
            text: 'Date',
            emoji: true
          },
          element: {
            type: 'datepicker',
            action_id: 'date_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select date'
            },
            initial_date: metadata.date || new Date().toISOString().split('T')[0]
          }
        },
        // Time Selection
        {
          type: 'input',
          block_id: 'schedule_time',
          label: {
            type: 'plain_text',
            text: 'Time (24-hour format)',
            emoji: true
          },
          element: {
            type: 'timepicker',
            action_id: 'time_select',
            placeholder: {
              type: 'plain_text',
              text: 'Select time'
            },
            initial_time: metadata.time || '09:00'
          }
        },
        // Recurring Options (shown if recurring is selected)
        ...(metadata.scheduleType === 'recurring' ? [
          {
            type: 'section',
            block_id: 'recurring_options',
            text: {
              type: 'mrkdwn',
              text: '*Repeat:*'
            },
            accessory: {
              type: 'static_select',
              action_id: 'recurring_frequency',
              placeholder: {
                type: 'plain_text',
                text: 'Select frequency'
              },
              initial_option: metadata.frequency ? {
                text: {
                  type: 'plain_text',
                  text: metadata.frequency.charAt(0).toUpperCase() + metadata.frequency.slice(1)
                },
                value: metadata.frequency
              } : undefined,
              options: [
                {
                  text: { type: 'plain_text', text: 'Daily' },
                  value: 'daily'
                },
                {
                  text: { type: 'plain_text', text: 'Weekly' },
                  value: 'weekly'
                },
                {
                  text: { type: 'plain_text', text: 'Monthly' },
                  value: 'monthly'
                }
              ]
            }
          }
        ] : []),
        // Message Preview
        {
          type: 'divider'
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '*üì± Message Preview:*\n' + (metadata.message || '_Your message will appear here_')
          }
        }
      ]
    };
  }

  // View Scheduled Messages
  static viewScheduledMessages(userId) {
    const userMessages = Array.from(scheduledMessages.values()).filter(msg => 
      msg.userId === userId && msg.status === 'active'
    );
    
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üìÖ Your Scheduled Messages',
          emoji: true
        }
      }
    ];
    
    if (userMessages.length === 0) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: '_No scheduled messages found. Create one to get started!_'
        }
      });
    } else {
      userMessages.forEach(msg => {
        const scheduleText = msg.scheduleType === 'recurring' ? 
          `üîÑ ${msg.frequency} at ${msg.time}` : 
          `üìÖ ${msg.date} at ${msg.time}`;
        
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Channel:* <#${msg.channel}>\n` +
                  `*Schedule:* ${scheduleText}\n` +
                  `*Message:* ${msg.message.substring(0, 100)}${msg.message.length > 100 ? '...' : ''}\n` +
                  `*Status:* ${msg.status === 'active' ? '‚úÖ Active' : '‚è∏Ô∏è Paused'}`
          },
          accessory: {
            type: 'overflow',
            action_id: `message_actions_${msg.id}`,
            options: [
              {
                text: {
                  type: 'plain_text',
                  text: '‚úèÔ∏è Edit',
                  emoji: true
                },
                value: `edit_${msg.id}`
              },
              {
                text: {
                  type: 'plain_text',
                  text: msg.status === 'active' ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Resume',
                  emoji: true
                },
                value: msg.status === 'active' ? `pause_${msg.id}` : `resume_${msg.id}`
              },
              {
                text: {
                  type: 'plain_text',
                  text: 'üóëÔ∏è Delete',
                  emoji: true
                },
                value: `delete_${msg.id}`
              },
              {
                text: {
                  type: 'plain_text',
                  text: 'üì§ Send Now',
                  emoji: true
                },
                value: `send_now_${msg.id}`
              }
            ]
          }
        });
        blocks.push({ type: 'divider' });
      });
    }
    
    blocks.push({
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'üîô Back to Menu',
            emoji: true
          },
          action_id: 'back_to_menu'
        },
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: '‚ûï Schedule New',
            emoji: true
          },
          style: 'primary',
          action_id: 'open_scheduler'
        }
      ]
    });
    
    return {
      type: 'modal',
      callback_id: 'view_scheduled_messages',
      title: {
        type: 'plain_text',
        text: 'Scheduled Messages',
        emoji: true
      },
      blocks
    };
  }

  // View Active Polls
  static activePollsList(userId) {
    const userPolls = Array.from(polls.values()).filter(poll => 
      poll.creator === userId && poll.status === 'active'
    );
    
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: 'üìä Your Active Polls',
          emoji: true
        }
      }
    ];
    
    if (userPolls.length === 0) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: '_No active polls found. Create one to get started!_'
        }
      });
    } else {
      userPolls.forEach(poll => {
        const voteCount = Object.keys(poll.votes || {}).length;
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${poll.question}*\n` +
                  `Channel: <#${poll.channel}>\n` +
                  `Votes: ${voteCount}\n` +
                  `Created: ${formatDate(poll.created)}`
          },
          accessory: {
            type: 'overflow',
            action_id: `poll_actions_${poll.id}`,
            options: [
              {
                text: { type: 'plain_text', text: 'üìà View Results' },
                value: `view_results_${poll.id}`
              },
              {
                text: { type: 'plain_text', text: 'üîÑ Refresh Poll' },
                value: `refresh_${poll.id}`
              },
              {
                text: { type: 'plain_text', text: 'üèÅ Close Poll' },
                value: `close_${poll.id}`
              }
            ]
          }
        });
        blocks.push({ type: 'divider' });
      });
    }
    
    blocks.push({
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'üîô Back to Menu',
            emoji: true
          },
          action_id: 'back_to_menu'
        },
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: '‚ûï Create New Poll',
            emoji: true
          },
          style: 'primary',
          action_id: 'open_poll_creator'
        }
      ]
    });
    
    return {
      type: 'modal',
      callback_id: 'active_polls_list',
      title: {
        type: 'plain_text',
        text: 'Active Polls',
        emoji: true
      },
      blocks
    };
  }

  // Delete Confirmation Modal
  static deleteConfirmation(messageId) {
    const message = scheduledMessages.get(messageId);
    
    return {
      type: 'modal',
      callback_id: 'confirm_delete_message',
      private_metadata: messageId,
      title: {
        type: 'plain_text',
        text: 'Confirm Delete',
        emoji: true
      },
      submit: {
        type: 'plain_text',
        text: 'Delete',
        emoji: true,
        style: 'danger'
      },
      close: {
        type: 'plain_text',
        text: 'Cancel',
        emoji: true
      },
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: '‚ö†Ô∏è *Are you sure you want to delete this scheduled message?*\n\n' +
                  'This action cannot be undone.'
          }
        },
        {
          type: 'divider'
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Channel:* <#${message.channel}>\n` +
                  `*Message:* ${message.message.substring(0, 200)}${message.message.length > 200 ? '...' : ''}`
          }
        }
      ]
    };
  }

  static generateProgressBar(percentage) {
    const filled = Math.round(percentage / 10);
    const empty = 10 - filled;
    return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
  }
}

// ============================================
// SLASH COMMAND HANDLER
// ============================================

app.command('/bot', async ({ command, ack, client }) => {
  await ack();
  
  try {
    const result = await client.views.open(
      ModalBuilder.mainMenu(command.trigger_id)
    );
    
    console.log('Main menu opened:', result.view.id);
  } catch (error) {
    console.error('Error opening main menu:', error);
  }
});

// ============================================
// NAVIGATION ACTION HANDLERS
// ============================================

// Back to Menu Navigation - CRITICAL WITH HASH
app.action('back_to_menu', async ({ body, ack, client }) => {
  await ack();
  
  try {
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // CRITICAL: Include hash
      view: {
        type: 'modal',
        callback_id: 'main_menu',
        title: {
          type: 'plain_text',
          text: 'Bot Dashboard',
          emoji: true
        },
        blocks: ModalBuilder.mainMenu().view.blocks
      }
    });
  } catch (error) {
    console.error('Error returning to menu:', error);
  }
});

// ============================================
// POLL ACTION HANDLERS
// ============================================

// Open Poll Creator
app.action('open_poll_creator', async ({ body, ack, client }) => {
  await ack();
  
  try {
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.pollCreator()
    });
  } catch (error) {
    console.error('Error opening poll creator:', error);
  }
});

// Template Selection Handler
app.action('select_template', async ({ body, ack, client }) => {
  await ack();
  
  try {
    const selectedTemplate = body.actions[0].selected_option.value;
    const currentMetadata = JSON.parse(body.view.private_metadata || '{}');
    
    const updatedMetadata = {
      ...currentMetadata,
      template: selectedTemplate,
      options: selectedTemplate === 'custom' ? currentMetadata.options : POLL_TEMPLATES[selectedTemplate].options
    };
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.pollCreator(updatedMetadata)
    });
  } catch (error) {
    console.error('Error updating template:', error);
  }
});

// Add Poll Option Handler
app.action('add_poll_option', async ({ body, ack, client }) => {
  await ack();
  
  try {
    const currentMetadata = JSON.parse(body.view.private_metadata || '{}');
    const stateValues = body.view.state.values;
    const options = [];
    
    for (let i = 0; i < 10; i++) {
      const blockId = `option_${i}`;
      if (stateValues[blockId]) {
        const value = stateValues[blockId][`option_input_${i}`]?.value;
        if (value) options.push(value);
      }
    }
    
    options.push('');
    
    const updatedMetadata = {
      ...currentMetadata,
      options,
      template: 'custom'
    };
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.pollCreator(updatedMetadata)
    });
  } catch (error) {
    console.error('Error adding poll option:', error);
  }
});

// View Active Polls
app.action('view_active_polls', async ({ body, ack, client }) => {
  await ack();
  
  try {
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.activePollsList(body.user.id)
    });
  } catch (error) {
    console.error('Error viewing active polls:', error);
  }
});

// Poll Overflow Menu Actions
app.action(/^poll_actions_.*/, async ({ body, ack, client }) => {
  await ack();
  
  try {
    const selectedOption = body.actions[0].selected_option;
    const [action, , pollId] = selectedOption.value.split('_');
    
    if (action === 'view' && selectedOption.value.startsWith('view_results')) {
      // View results logic here
    } else if (action === 'close') {
      const poll = polls.get(pollId);
      if (poll) {
        poll.status = 'closed';
        await postPollResults(client, poll);
      }
      
      await client.views.update({
        view_id: body.view.id,
        hash: body.view.hash, // Include hash
        view: ModalBuilder.activePollsList(body.user.id)
      });
    }
  } catch (error) {
    console.error('Error handling poll action:', error);
  }
});

// Poll Vote Handler
app.action(/^poll_vote_.*/, async ({ body, ack, client }) => {
  await ack();
  
  try {
    const [, , pollId, optionIndex] = body.actions[0].action_id.split('_');
    const poll = polls.get(pollId);
    
    if (!poll || poll.status !== 'active') {
      await client.chat.postEphemeral({
        channel: body.channel.id,
        user: body.user.id,
        text: '‚ùå This poll is no longer active.'
      });
      return;
    }
    
    const userId = body.user.id;
    const selectedOption = poll.options[parseInt(optionIndex)];
    
    if (!poll.votes[userId]) {
      poll.votes[userId] = [];
    }
    
    if (poll.allowMultiple) {
      const voteIndex = poll.votes[userId].indexOf(selectedOption);
      if (voteIndex > -1) {
        poll.votes[userId].splice(voteIndex, 1);
      } else {
        poll.votes[userId].push(selectedOption);
      }
    } else {
      poll.votes[userId] = [selectedOption];
    }
    
    await updatePollMessage(client, poll);
    
    await client.chat.postEphemeral({
      channel: body.channel.id,
      user: userId,
      text: `‚úÖ Your vote has been recorded!`
    });
    
  } catch (error) {
    console.error('Error handling vote:', error);
  }
});

// ============================================
// SCHEDULED MESSAGE ACTION HANDLERS
// ============================================

// Open Message Scheduler
app.action('open_scheduler', async ({ body, ack, client }) => {
  await ack();
  
  try {
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.messageScheduler()
    });
  } catch (error) {
    console.error('Error opening scheduler:', error);
  }
});

// View Scheduled Messages
app.action('view_scheduled', async ({ body, ack, client }) => {
  await ack();
  
  try {
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.viewScheduledMessages(body.user.id)
    });
  } catch (error) {
    console.error('Error viewing scheduled messages:', error);
  }
});

// Handle Schedule Type Change
app.action('schedule_type_select', async ({ body, ack, client }) => {
  await ack();
  
  try {
    const selectedType = body.actions[0].selected_option.value;
    const currentMetadata = JSON.parse(body.view.private_metadata || '{}');
    
    const updatedMetadata = {
      ...currentMetadata,
      scheduleType: selectedType
    };
    
    await client.views.update({
      view_id: body.view.id,
      hash: body.view.hash, // Include hash
      view: ModalBuilder.messageScheduler(updatedMetadata)
    });
  } catch (error) {
    console.error('Error updating schedule type:', error);
  }
});

// Handle Message Actions (Edit, Delete, Pause, Resume, Send Now)
app.action(/^message_actions_.*/, async ({ body, ack, client }) => {
  await ack();
  
  try {
    const selectedOption = body.actions[0].selected_option;
    const [action, messageId] = selectedOption.value.split('_');
    
    switch (action) {
      case 'edit':
        const messageToEdit = scheduledMessages.get(messageId);
        if (messageToEdit) {
          await client.views.push({
            trigger_id: body.trigger_id,
            view: ModalBuilder.messageScheduler({
              messageId,
              channel: messageToEdit.channel,
              message: messageToEdit.message,
              scheduleType: messageToEdit.scheduleType,
              date: messageToEdit.date,
              time: messageToEdit.time,
              frequency: messageToEdit.frequency
            })
          });
        }
        break;
        
      case 'delete':
        await client.views.push({
          trigger_id: body.trigger_id,
          view: ModalBuilder.deleteConfirmation(messageId)
        });
        break;
        
      case 'pause':
        const messageToPause = scheduledMessages.get(messageId);
        if (messageToPause) {
          messageToPause.status = 'paused';
          
          const job = activeJobs.get(messageId);
          if (job) {
            job.cancel();
            activeJobs.delete(messageId);
          }
          
          await client.views.update({
            view_id: body.view.id,
            hash: body.view.hash, // Include hash
            view: ModalBuilder.viewScheduledMessages(body.user.id)
          });
          
          await client.chat.postEphemeral({
            channel: body.user.id,
            user: body.user.id,
            text: '‚è∏Ô∏è Message paused successfully'
          });
        }
        break;
        
      case 'resume':
        const messageToResume = scheduledMessages.get(messageId);
        if (messageToResume) {
          messageToResume.status = 'active';
          scheduleMessage(client, messageToResume);
          
          await client.views.update({
            view_id: body.view.id,
            hash: body.view.hash, // Include hash
            view: ModalBuilder.viewScheduledMessages(body.user.id)
          });
          
          await client.chat.postEphemeral({
            channel: body.user.id,
            user: body.user.id,
            text: '‚ñ∂Ô∏è Message resumed successfully'
          });
        }
        break;
        
      case 'send':
        const messageToSend = scheduledMessages.get(messageId);
        if (messageToSend) {
          await client.chat.postMessage({
            channel: messageToSend.channel,
            text: messageToSend.message
          });
          
          await client.chat.postEphemeral({
            channel: body.user.id,
            user: body.user.id,
            text: 'üì§ Message sent successfully!'
          });
        }
        break;
    }
  } catch (error) {
    console.error('Error handling message action:', error);
  }
});

// ============================================
// VIEW SUBMISSION HANDLERS
// ============================================

// Handle Poll Creation
app.view('poll_creator', async ({ ack, body, view, client }) => {
  const values = view.state.values;
  const metadata = JSON.parse(view.private_metadata || '{}');
  
  const errors = {};
  
  const question = values.poll_question?.question_input?.value;
  if (!question || question.trim().length === 0) {
    errors.poll_question = "Please enter a poll question";
  }
  
  const channel = values.poll_channel?.channel_select?.selected_channel;
  if (!channel) {
    errors.poll_channel = "Please select a channel";
  }
  
  const options = [];
  if (metadata.template === 'custom') {
    for (let i = 0; i < 10; i++) {
      const blockId = `option_${i}`;
      if (values[blockId]) {
        const value = values[blockId][`option_input_${i}`]?.value;
        if (value && value.trim()) {
          options.push(value.trim());
        }
      }
    }
    
    if (options.length < 2) {
      errors.option_0 = "Please provide at least 2 options";
    }
  } else {
    options.push(...POLL_TEMPLATES[metadata.template].options);
  }
  
  const uniqueOptions = new Set(options);
  if (uniqueOptions.size !== options.length) {
    errors.option_1 = "Options must be unique";
  }
  
  if (Object.keys(errors).length > 0) {
    await ack({
      response_action: 'errors',
      errors
    });
    return;
  }
  
  const pollId = generateId();
  const poll = {
    id: pollId,
    question: question.trim(),
    options,
    channel,
    creator: body.user.id,
    created: new Date().toISOString(),
    votes: {},
    status: 'active',
    allowMultiple: values.multiple_choice?.multiple_toggle?.selected_options?.length > 0,
    anonymous: values.anonymous_voting?.anonymous_toggle?.selected_options?.length > 0,
    timeLimit: values.time_limit?.time_select?.selected_option?.value || 'none'
  };
  
  polls.set(pollId, poll);
  
  try {
    const result = await client.chat.postMessage({
      channel,
      blocks: generatePollBlocks(poll),
      text: `Poll: ${question}`
    });
    
    poll.messageTs = result.ts;
    
    if (poll.timeLimit !== 'none') {
      const minutes = parseInt(poll.timeLimit);
      setTimeout(async () => {
        poll.status = 'closed';
        await postPollResults(client, poll);
      }, minutes * 60 * 1000);
    }
    
    await ack();
    
    await client.chat.postEphemeral({
      channel,
      user: body.user.id,
      text: `‚úÖ Your poll "${question}" has been created!`
    });
    
  } catch (error) {
    console.error('Error posting poll:', error);
    await ack({
      response_action: 'errors',
      errors: {
        poll_channel: "Failed to post poll. Please check bot permissions."
      }
    });
  }
});

// Handle Schedule Message Submission
app.view('schedule_message', async ({ ack, body, view, client }) => {
  const values = view.state.values;
  const metadata = JSON.parse(view.private_metadata || '{}');
  
  const errors = {};
  
  const channel = values.message_channel?.channel_select?.selected_channel;
  if (!channel) {
    errors.message_channel = "Please select a channel";
  }
  
  const message = values.message_content?.message_input?.value;
  if (!message || message.trim().length === 0) {
    errors.message_content = "Please enter a message";
  }
  
  if (Object.keys(errors).length > 0) {
    await ack({
      response_action: 'errors',
      errors
    });
    return;
  }
  
  const messageId = metadata.messageId || generateId();
  const scheduledMessage = {
    id: messageId,
    userId: body.user.id,
    channel,
    message: message.trim(),
    scheduleType: values.schedule_type?.schedule_type_select?.selected_option?.value || 'one_time',
    date: values.schedule_date?.date_select?.selected_date,
    time: values.schedule_time?.time_select?.selected_time,
    frequency: values.recurring_options?.recurring_frequency?.selected_option?.value,
    status: 'active',
    created: new Date().toISOString()
  };
  
  scheduledMessages.set(messageId, scheduledMessage);
  scheduleMessage(client, scheduledMessage);
  
  await ack();
  
  await client.chat.postEphemeral({
    channel: scheduledMessage.channel,
    user: body.user.id,
    text: `‚úÖ Your message has been scheduled successfully!`
  });
});

// Handle Edit Message Submission
app.view('edit_scheduled_message', async ({ ack, body, view, client }) => {
  const values = view.state.values;
  const metadata = JSON.parse(view.private_metadata || '{}');
  const messageId = metadata.messageId;
  
  if (!messageId) {
    await ack({
      response_action: 'errors',
      errors: {
        message_content: "Message ID not found"
      }
    });
    return;
  }
  
  const oldJob = activeJobs.get(messageId);
  if (oldJob) {
    oldJob.cancel();
    activeJobs.delete(messageId);
  }
  
  const updatedMessage = {
    id: messageId,
    userId: body.user.id,
    channel: values.message_channel?.channel_select?.selected_channel,
    message: values.message_content?.message_input?.value?.trim(),
    scheduleType: values.schedule_type?.schedule_type_select?.selected_option?.value || 'one_time',
    date: values.schedule_date?.date_select?.selected_date,
    time: values.schedule_time?.time_select?.selected_time,
    frequency: values.recurring_options?.recurring_frequency?.selected_option?.value,
    status: 'active',
    updated: new Date().toISOString()
  };
  
  scheduledMessages.set(messageId, updatedMessage);
  scheduleMessage(client, updatedMessage);
  
  await ack();
  
  await client.chat.postEphemeral({
    channel: updatedMessage.channel,
    user: body.user.id,
    text: `‚úÖ Your scheduled message has been updated!`
  });
});

// Handle Delete Confirmation
app.view('confirm_delete_message', async ({ ack, body, view, client }) => {
  const messageId = view.private_metadata;
  
  const job = activeJobs.get(messageId);
  if (job) {
    job.cancel();
    activeJobs.delete(messageId);
  }
  
  const message = scheduledMessages.get(messageId);
  scheduledMessages.delete(messageId);
  
  await ack();
  
  if (message) {
    await client.chat.postEphemeral({
      channel: message.channel,
      user: body.user.id,
      text: `üóëÔ∏è Scheduled message has been deleted successfully.`
    });
  }
});

// ============================================
// HELPER FUNCTIONS
// ============================================

function generatePollBlocks(poll) {
  const blocks = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: 'üìä ' + poll.question,
        emoji: true
      }
    }
  ];
  
  const info = [];
  if (poll.allowMultiple) info.push('‚úì Multiple selections allowed');
  if (poll.anonymous) info.push('üîí Anonymous voting');
  if (poll.timeLimit !== 'none') info.push(`‚è±Ô∏è Closes in ${poll.timeLimit} minutes`);
  
  if (info.length > 0) {
    blocks.push({
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: info.join(' ‚Ä¢ ')
        }
      ]
    });
  }
  
  blocks.push({ type: 'divider' });
  
  const elements = [];
  poll.options.forEach((option, index) => {
    const voteCount = Object.values(poll.votes || {})
      .filter(votes => votes.includes(option)).length;
    
    elements.push({
      type: 'button',
      text: {
        type: 'plain_text',
        text: `${option} (${voteCount})`,
        emoji: true
      },
      action_id: `poll_vote_${poll.id}_${index}`,
      value: option
    });
  });
  
  for (let i = 0; i < elements.length; i += 5) {
    blocks.push({
      type: 'actions',
      elements: elements.slice(i, i + 5)
    });
  }
  
  const totalVotes = Object.keys(poll.votes || {}).length;
  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: `Total votes: ${totalVotes} ‚Ä¢ Created by <@${poll.creator}>`
      }
    ]
  });
  
  return blocks;
}

async function updatePollMessage(client, poll) {
  if (!poll.messageTs) return;
  
  try {
    await client.chat.update({
      channel: poll.channel,
      ts: poll.messageTs,
      blocks: generatePollBlocks(poll),
      text: `Poll: ${poll.question}`
    });
  } catch (error) {
    console.error('Error updating poll message:', error);
  }
}

async function postPollResults(client, poll) {
  const totalVotes = Object.keys(poll.votes || {}).length;
  const voteCounts = {};
  
  poll.options.forEach(option => {
    voteCounts[option] = Object.values(poll.votes || {})
      .filter(votes => votes.includes(option)).length;
  });
  
  const sortedOptions = poll.options.sort((a, b) => voteCounts[b] - voteCounts[a]);
  
  const blocks = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: 'üèÅ Poll Closed: ' + poll.question,
        emoji: true
      }
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '*Final Results:*'
      }
    }
  ];
  
  sortedOptions.forEach((option, index) => {
    const votes = voteCounts[option];
    const percentage = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
    const bar = ModalBuilder.generateProgressBar(percentage);
    
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `${index + 1}. *${option}*\n${bar} ${percentage}% (${votes} votes)`
      }
    });
  });
  
  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: `Total participants: ${totalVotes} ‚Ä¢ Poll by <@${poll.creator}>`
      }
    ]
  });
  
  await client.chat.postMessage({
    channel: poll.channel,
    blocks,
    text: `Poll closed: ${poll.question}`
  });
}

function scheduleMessage(client, message) {
  const existingJob = activeJobs.get(message.id);
  if (existingJob) {
    existingJob.cancel();
  }
  
  if (message.scheduleType === 'one_time') {
    const [hours, minutes] = message.time.split(':');
    const scheduledDate = new Date(message.date);
    scheduledDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    
    if (scheduledDate > new Date()) {
      const job = schedule.scheduleJob(scheduledDate, async () => {
        await sendScheduledMessage(client, message);
        message.status = 'completed';
        activeJobs.delete(message.id);
      });
      
      activeJobs.set(message.id, job);
    }
  } else if (message.scheduleType === 'recurring') {
    const [hours, minutes] = message.time.split(':');
    let cronPattern;
    
    if (message.frequency === 'daily') {
      cronPattern = `${minutes} ${hours} * * *`;
    } else if (message.frequency === 'weekly') {
      cronPattern = `${minutes} ${hours} * * 1`; // Every Monday
    } else if (message.frequency === 'monthly') {
      cronPattern = `${minutes} ${hours} 1 * *`; // First day of month
    } else {
      return;
    }
    
    const job = schedule.scheduleJob(cronPattern, async () => {
      await sendScheduledMessage(client, message);
    });
    
    activeJobs.set(message.id, job);
  }
}

async function sendScheduledMessage(client, message) {
  try {
    await client.chat.postMessage({
      channel: message.channel,
      text: message.message,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: message.message
          }
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `_Scheduled message from <@${message.userId}>_`
            }
          ]
        }
      ]
    });
    
    console.log(`Sent scheduled message: ${message.id}`);
  } catch (error) {
    console.error('Error sending scheduled message:', error);
  }
}

// ============================================
// ERROR HANDLER
// ============================================

app.error(async (error) => {
  console.error('Global error handler:', error);
});

// ============================================
// INITIALIZATION & STARTUP
// ============================================

async function initializeScheduledMessages(client) {
  for (const [messageId, message] of scheduledMessages.entries()) {
    if (message.status === 'active') {
      scheduleMessage(client, message);
    }
  }
  console.log(`Initialized ${scheduledMessages.size} scheduled messages`);
}

// Start the app
(async () => {
  try {
    await app.start();
    await initializeScheduledMessages(app.client);
    
    console.log('‚ö°Ô∏è Enhanced Slack Bot is running!');
    console.log('‚úÖ Features enabled:');
    console.log('   - Interactive Polls with Templates');
    console.log('   - Scheduled Messages with Edit/Delete');
    console.log('   - Fixed Navigation with Hash Management');
    console.log('   - Real-time Updates');
    console.log('\nUse /bot command to get started!');
    
  } catch (error) {
    console.error('Failed to start app:', error);
  }
})();
