/**
 * PM Squad Bot - Cleaned Up Version
 * Removed contradictions, simplified handlers, clear data flow
 */

const { App } = require('@slack/bolt');
const cron = require('node-cron');
const fs = require('fs');
require('dotenv').config();

// ================================
// INITIALIZATION
// ================================

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  appToken: process.env.SLACK_APP_TOKEN,
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  socketMode: true,
  port: process.env.PORT || 3000
});

// ================================
// STATE MANAGEMENT
// ================================

const SCHEDULE_FILE = './scheduledMessages.json';
let scheduledMessages = [];
const jobs = new Map();
const pollVotes = {};
const formData = new Map(); // Single source of truth for form state

// ================================
// UTILITIES
// ================================

const generateId = () => `msg_${Date.now()}_${Math.floor(Math.random() * 100000)}`;
const cat = () => Math.random() < 0.35 ? ` ${['‚Çç^. .^‚Çé‚üÜ', '·ìö‚Çç ^. .^‚Çé', '‡∏Ö^‚Ä¢Ôªå‚Ä¢^‡∏Ö'][Math.floor(Math.random() * 3)]}` : '';

function todayInEST() {
  return new Intl.DateTimeFormat('en-CA', { timeZone: 'America/New_York' }).format(new Date());
}

function formatTimeDisplay(timeStr) {
  const [hour, minute] = timeStr.split(':').map(Number);
  const period = hour >= 12 ? 'PM' : 'AM';
  const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
  return `${displayHour}:${minute.toString().padStart(2, '0')} ${period}`;
}

function isDateTimeInPast(dateStr, timeStr) {
  try {
    const now = new Date();
    const currentEST = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'America/New_York',
      year: 'numeric', month: '2-digit', day: '2-digit'
    }).format(now);
    
    const currentTimeEST = new Intl.DateTimeFormat('en-GB', {
      timeZone: 'America/New_York',
      hour: '2-digit', minute: '2-digit', hour12: false
    }).format(now);

    if (dateStr !== currentEST) return dateStr < currentEST;
    return timeStr < currentTimeEST;
  } catch (error) {
    console.error('Timezone error:', error);
    return false;
  }
}

// ================================
// STORAGE
// ================================

function saveMessages() {
  try {
    fs.writeFileSync(SCHEDULE_FILE, JSON.stringify(scheduledMessages, null, 2));
  } catch (e) {
    console.error('Save failed:', e);
  }
}

function loadMessages() {
  if (fs.existsSync(SCHEDULE_FILE)) {
    try {
      const data = JSON.parse(fs.readFileSync(SCHEDULE_FILE));
      scheduledMessages = data.filter(msg => {
        if (msg.repeat !== 'none') return true;
        return !isDateTimeInPast(msg.date, msg.time);
      });
      saveMessages();
    } catch (e) {
      console.error('Load failed:', e);
      scheduledMessages = [];
    }
  }
}

loadMessages();

// ================================
// TEMPLATES
// ================================

const templates = {
  capacity: "**Daily Bandwidth Check**\nHow's everyone's capacity looking today?\n\nUse the reactions below to share your current workload:\nüü¢ Light schedule - Ready for new work\nüü° Manageable schedule\nüü† Schedule is full, no new work\nüî¥ Overloaded - Need help now",
  help: "**Need Backup?**\nIf you're stuck or need assistance, click the button below to alert the team."
};

// ================================
// MODAL CREATION
// ================================

function createModal(page, data = {}) {
  const base = {
    type: 'modal',
    callback_id: `scheduler_${page}`,
    title: { type: 'plain_text', text: 'PM Squad Manager' },
    close: { type: 'plain_text', text: 'Cancel' }
  };

  if (page === 'menu') {
    return {
      ...base,
      title: { type: 'plain_text', text: 'Cat Scratch Menu' },
      blocks: [
        { type: 'section', text: { type: 'mrkdwn', text: '*Choose a message type:*' }},
        { type: 'divider' },
        {
          type: 'actions',
          elements: [
            { type: 'button', text: { type: 'plain_text', text: 'Capacity Check' }, action_id: 'nav_capacity' },
            { type: 'button', text: { type: 'plain_text', text: 'Poll' }, action_id: 'nav_poll' }
          ]
        },
        {
          type: 'actions',
          elements: [
            { type: 'button', text: { type: 'plain_text', text: 'Help Button' }, action_id: 'nav_help' },
            { type: 'button', text: { type: 'plain_text', text: 'Custom Message' }, action_id: 'nav_custom' }
          ]
        },
        { type: 'divider' },
        {
          type: 'actions',
          elements: [
            { type: 'button', text: { type: 'plain_text', text: 'View Scheduled' }, action_id: 'nav_scheduled' }
          ]
        }
      ]
    };
  }

  if (page === 'scheduled') {
    const blocks = [
      { type: 'section', text: { type: 'mrkdwn', text: `*Scheduled Messages* (${scheduledMessages.length} total)` }},
      { type: 'divider' }
    ];

    if (scheduledMessages.length === 0) {
      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: `_No scheduled messages yet_${cat()}` }});
    } else {
      scheduledMessages.forEach(msg => {
        const nextRun = msg.repeat === 'none' ? 
          `${msg.date} at ${formatTimeDisplay(msg.time)}` : 
          `${msg.repeat} at ${formatTimeDisplay(msg.time)}`;
        
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${msg.title || msg.type}*\nüìÖ ${nextRun}\nüìç <#${msg.channel}>\n_${(msg.text || '').substring(0, 100)}${(msg.text || '').length > 100 ? '...' : ''}_`
          },
          accessory: {
            type: 'button',
            style: 'danger',
            text: { type: 'plain_text', text: 'Delete' },
            action_id: `delete_message_${msg.id}`,
            value: msg.id,
            confirm: {
              title: { type: 'plain_text', text: 'Delete Message' },
              text: { type: 'mrkdwn', text: `Delete "${msg.title || msg.type}"?` },
              confirm: { type: 'plain_text', text: 'Delete' },
              deny: { type: 'plain_text', text: 'Cancel' }
            }
          }
        });
      });
    }

    blocks.push(
      { type: 'divider' },
      { type: 'actions', elements: [{ type: 'button', text: { type: 'plain_text', text: '‚Üê Back' }, action_id: 'nav_menu' }]}
    );

    return { ...base, blocks };
  }

  if (page === 'preview') {
    let previewText = '';
    
    if (data.type === 'capacity') {
      previewText = data.text || templates.capacity;
    } else if (data.type === 'poll') {
      previewText = `*${data.title || 'Poll'}*\n${data.text || ''}`;
      
      if (data.pollType === 'open') {
        previewText += '\n_Open discussion - responses in thread_';
      } else if (data.pollOptions) {
        const options = data.pollOptions.split('\n').filter(o => o.trim());
        previewText += '\n' + options.map((opt, i) => `${i + 1}. ${opt.trim()}`).join('\n');
        previewText += `\n_Type: ${data.pollType === 'single' ? 'Single choice' : 'Multiple choice'}_`;
      }
    } else if (data.type === 'help') {
      previewText = data.text || templates.help;
      previewText += '\n\nüÜò Request Backup (button)';
    } else {
      if (data.title) previewText += `*${data.title}*\n`;
      previewText += data.text || '(no content)';
    }

    return {
      ...base,
      title: { type: 'plain_text', text: `${data.type || 'Message'} Preview` },
      blocks: [
        { type: 'section', text: { type: 'mrkdwn', text: '*Step 2: Preview Your Message*' }},
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Preview:*\n\`\`\`${previewText.substring(0, 500)}${previewText.length > 500 ? '...' : ''}\`\`\``
          }
        },
        { type: 'divider' },
        {
          type: 'actions',
          elements: [
            { type: 'button', text: { type: 'plain_text', text: '‚Üê Back to Edit' }, action_id: `nav_${data.type || 'custom'}` },
            { type: 'button', style: 'primary', text: { type: 'plain_text', text: 'Continue to Schedule' }, action_id: 'nav_schedule' }
          ]
        }
      ]
    };
  }

  if (page === 'schedule') {
    const blocks = [
      { type: 'section', text: { type: 'mrkdwn', text: '*Step 3: Send or Schedule Message*' }},
      { type: 'divider' },
      { type: 'section', text: { type: 'mrkdwn', text: '*Where to send:*' }},
      {
        type: 'input',
        block_id: 'channel_block',
        label: { type: 'plain_text', text: 'Target Channel' },
        element: {
          type: 'conversations_select',
          action_id: 'channel_select',
          ...(data.channel && { initial_conversation: data.channel }),
          placeholder: { type: 'plain_text', text: 'Select channel' }
        }
      }
    ];

    // Add alert channels for help messages
    if (data.type === 'help') {
      blocks.push({
        type: 'input',
        block_id: 'alert_channels_block',
        label: { type: 'plain_text', text: 'Alert Channels' },
        element: {
          type: 'multi_conversations_select',
          action_id: 'alert_channels_select',
          ...(data.alertChannels?.length > 0 && { initial_conversations: data.alertChannels }),
          placeholder: { type: 'plain_text', text: 'Channels to alert when help is requested' }
        }
      });
    }

    // Timing section
    blocks.push(
      { type: 'divider' },
      { type: 'section', text: { type: 'mrkdwn', text: '*When to send:*' }},
      {
        type: 'actions',
        elements: [
          {
            type: 'button',
            text: { type: 'plain_text', text: 'üêà‚Äç‚¨õ Post Now' },
            style: data.scheduleType === 'now' ? 'primary' : undefined,
            action_id: 'timing_now'
          },
          {
            type: 'button',
            text: { type: 'plain_text', text: 'üß∂ Schedule for Later' },
            style: data.scheduleType === 'schedule' || !data.scheduleType ? 'primary' : undefined,
            action_id: 'timing_schedule'
          }
        ]
      }
    );

    // Show schedule fields only if scheduling
    if (data.scheduleType === 'schedule' || !data.scheduleType) {
      blocks.push(
        { type: 'divider' },
        { type: 'section', text: { type: 'mrkdwn', text: '*Schedule Details:*' }},
        {
          type: 'actions',
          block_id: 'datetime_block',
          elements: [
            {
              type: 'datepicker',
              action_id: 'date_picker',
              initial_date: data.date || todayInEST(),
              placeholder: { type: 'plain_text', text: 'Select date' }
            },
            {
              type: 'timepicker',
              action_id: 'time_picker',
              initial_time: data.time || '09:00',
              placeholder: { type: 'plain_text', text: 'Select time' }
            }
          ]
        },
        {
          type: 'input',
          block_id: 'repeat_block',
          label: { type: 'plain_text', text: 'Repeat Schedule' },
          element: {
            type: 'static_select',
            action_id: 'repeat_select',
            initial_option: { 
              text: { type: 'plain_text', text: data.repeat === 'daily' ? 'Daily' : data.repeat === 'weekly' ? 'Weekly' : data.repeat === 'monthly' ? 'Monthly' : 'None (One-time)' }, 
              value: data.repeat || 'none' 
            },
            options: [
              { text: { type: 'plain_text', text: 'None (One-time)' }, value: 'none' },
              { text: { type: 'plain_text', text: 'Daily' }, value: 'daily' },
              { text: { type: 'plain_text', text: 'Weekly' }, value: 'weekly' },
              { text: { type: 'plain_text', text: 'Monthly' }, value: 'monthly' }
            ]
          }
        }
      );
    }

    blocks.push(
      { type: 'divider' },
      {
        type: 'actions',
        elements: [
          { type: 'button', text: { type: 'plain_text', text: '‚Üê Back' }, action_id: 'nav_preview' }
        ]
      }
    );

    return {
      ...base,
      title: { type: 'plain_text', text: 'Send or Schedule Message' },
      submit: { type: 'plain_text', text: 'Post' },
      blocks
    };
  }

  // Form pages (capacity, poll, help, custom)
  const blocks = [
    { type: 'section', text: { type: 'mrkdwn', text: `*Step 1: Create ${page.charAt(0).toUpperCase() + page.slice(1)} Message*` }},
    { type: 'divider' }
  ];

  // Title field (polls and custom only)
  if (page === 'poll' || page === 'custom') {
    blocks.push({
      type: 'input',
      block_id: 'title_block',
      label: { type: 'plain_text', text: 'Title (optional)' },
      element: {
        type: 'plain_text_input',
        action_id: 'title_input',
        initial_value: data.title || '',
        placeholder: { type: 'plain_text', text: 'Message title...' }
      },
      optional: true
    });
  }

  // Text field
  let initialText = data.text || '';
  if (!initialText && page === 'capacity') initialText = templates.capacity;
  if (!initialText && page === 'help') initialText = templates.help;

  blocks.push({
    type: 'input',
    block_id: 'text_block',
    label: { type: 'plain_text', text: 'Message Text' },
    element: {
      type: 'plain_text_input',
      action_id: 'text_input',
      multiline: true,
      initial_value: initialText,
      placeholder: { type: 'plain_text', text: 'Message content...' }
    }
  });

  // Poll-specific blocks
  if (page === 'poll') {
    blocks.push(
      { type: 'divider' },
      { type: 'section', text: { type: 'mrkdwn', text: '*Poll Configuration*' }},
      {
        type: 'section',
        text: { type: 'mrkdwn', text: 'Poll type:' },
        accessory: {
          type: 'radio_buttons',
          action_id: 'poll_type_radio',
          options: [
            { text: { type: 'plain_text', text: 'Single Choice' }, value: 'single' },
            { text: { type: 'plain_text', text: 'Multiple Choice' }, value: 'multiple' },
            { text: { type: 'plain_text', text: 'Open Discussion' }, value: 'open' }
          ],
          initial_option: { 
            text: { type: 'plain_text', text: data.pollType === 'multiple' ? 'Multiple Choice' : data.pollType === 'open' ? 'Open Discussion' : 'Single Choice' }, 
            value: data.pollType || 'single' 
          }
        }
      }
    );

    // Poll options (if not open discussion)
    if (data.pollType !== 'open') {
      blocks.push({ type: 'section', text: { type: 'mrkdwn', text: '*Poll Options*' }});
      
      const options = data.pollOptions ? data.pollOptions.split('\n').filter(Boolean) : ['Option 1', 'Option 2'];
      
      options.forEach((option, index) => {
        blocks.push({
          type: 'input',
          block_id: `option_${index}_block`,
          label: { type: 'plain_text', text: `Option ${index + 1}` },
          element: {
            type: 'plain_text_input',
            action_id: `option_${index}_input`,
            initial_value: option,
            placeholder: { type: 'plain_text', text: `Enter option ${index + 1}...` }
          },
          optional: index >= 2
        });
      });

      // Add/remove buttons
      const actionElements = [];
      if (options.length < 10) {
        actionElements.push({
          type: 'button',
          text: { type: 'plain_text', text: 'Add Option' },
          action_id: 'add_poll_option'
        });
      }
      if (options.length > 2) {
        actionElements.push({
          type: 'button',
          text: { type: 'plain_text', text: 'Remove Last' },
          action_id: 'remove_poll_option',
          style: 'danger'
        });
      }

      if (actionElements.length > 0) {
        blocks.push({ type: 'actions', elements: actionElements });
      }
    }
  }

  blocks.push(
    { type: 'divider' },
    {
      type: 'actions',
      elements: [
        { type: 'button', text: { type: 'plain_text', text: '‚Üê Back' }, action_id: 'nav_menu' },
        { type: 'button', style: 'primary', text: { type: 'plain_text', text: 'Preview' }, action_id: 'nav_preview' }
      ]
    }
  );

  return {
    ...base,
    title: { type: 'plain_text', text: `${page.charAt(0).toUpperCase() + page.slice(1)} Message` },
    submit: { type: 'plain_text', text: 'Preview' },
    blocks
  };
}

// ================================
// MESSAGE SENDING
// ================================

async function sendMessage(msg) {
  try {
    console.log(`Sending ${msg.type} message to ${msg.channel}`);

    if (!msg.channel) {
      console.error('No channel specified');
      return false;
    }

    // Verify channel access
    try {
      const channelInfo = await app.client.conversations.info({ channel: msg.channel });
      console.log(`Channel verified: #${channelInfo.channel.name}`);
    } catch (error) {
      console.error(`Channel access failed: ${error.data?.error}`);
      return false;
    }

    if (msg.type === 'capacity') {
      const messageText = (msg.title ? `*${msg.title}*\n` : '') + (msg.text || templates.capacity) + cat();
      
      const result = await app.client.chat.postMessage({
        channel: msg.channel,
        text: messageText
      });

      // Add reactions
      if (result.ok && result.ts) {
        const reactions = ['green_circle', 'yellow_circle', 'orange_circle', 'red_circle'];
        for (const reaction of reactions) {
          try {
            await app.client.reactions.add({ 
              channel: msg.channel, 
              timestamp: result.ts, 
              name: reaction 
            });
          } catch (e) {
            console.error(`Reaction ${reaction} failed:`, e.data?.error);
          }
        }
      }
    } else if (msg.type === 'poll') {
      const options = (msg.pollOptions || '').split('\n').filter(Boolean);
      
      let blocks = [
        { type: 'section', text: { type: 'mrkdwn', text: `*${msg.title || 'Poll'}*${cat()}\n${msg.text || ''}` }}
      ];

      if (msg.pollType !== 'open' && options.length > 0) {
        const buttonElements = options.map((option, idx) => ({
          type: 'button',
          text: { type: 'plain_text', text: option.slice(0, 70) },
          action_id: `poll_vote_${msg.id}_${idx}`,
          value: `${idx}`
        }));

        for (let i = 0; i < buttonElements.length; i += 5) {
          blocks.push({
            type: 'actions',
            elements: buttonElements.slice(i, i + 5)
          });
        }
      }

      const contextText = msg.pollType === 'single' ? '_Click to vote. Click again to unvote._' :
        msg.pollType === 'multiple' ? '_Multiple choices allowed. Click to toggle._' :
        '_Open discussion - reply in thread._';

      blocks.push({ type: 'context', elements: [{ type: 'mrkdwn', text: contextText }]});

      await app.client.chat.postMessage({
        channel: msg.channel,
        text: msg.title || 'Poll',
        blocks
      });
    } else if (msg.type === 'help') {
      const blocks = [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: (msg.title ? `*${msg.title}*\n` : '') + (msg.text || templates.help) + cat()
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              style: 'danger',
              text: { type: 'plain_text', text: 'üÜò Request Backup' },
              action_id: `help_click_${msg.id}`,
              value: JSON.stringify({
                msgId: msg.id,
                alertChannels: msg.alertChannels || []
              })
            }
          ]
        }
      ];

      await app.client.chat.postMessage({
        channel: msg.channel,
        text: msg.text || 'Help button',
        blocks
      });
    } else {
      // Custom message
      const messageText = (msg.title ? `*${msg.title}*\n` : '') + (msg.text || '(no content)') + cat();
      
      await app.client.chat.postMessage({
        channel: msg.channel,
        text: messageText
      });
    }

    console.log(`${msg.type} message sent successfully`);
    return true;
  } catch (error) {
    console.error('Send failed:', error.data?.error || error.message);
    return false;
  }
}

// ================================
// SCHEDULING
// ================================

function scheduleJob(msg) {
  if (jobs.has(msg.id)) {
    try {
      jobs.get(msg.id).destroy();
    } catch (_) {}
    jobs.delete(msg.id);
  }

  const [hh, mm] = msg.time.split(':').map(Number);
  let cronExpr;

  if (msg.repeat === 'daily') {
    cronExpr = `${mm} ${hh} * * *`;
  } else if (msg.repeat === 'weekly') {
    const day = new Date(msg.date).getDay();
    cronExpr = `${mm} ${hh} * * ${day}`;
  } else if (msg.repeat === 'monthly') {
    const day = msg.date.split('-')[2];
    cronExpr = `${mm} ${hh} ${day} * *`;
  } else {
    const [y, mon, d] = msg.date.split('-');
    cronExpr = `${mm} ${hh} ${d} ${mon} *`;
  }

  console.log(`Scheduling ${msg.type}: ${cronExpr}`);

  const job = cron.schedule(cronExpr, async () => {
    console.log(`Executing scheduled ${msg.type} message`);
    const success = await sendMessage(msg);

    if (msg.repeat === 'none') {
      scheduledMessages = scheduledMessages.filter(m => m.id !== msg.id);
      saveMessages();
      try { job.destroy(); } catch (_) {}
      jobs.delete(msg.id);
    }
  }, { timezone: 'America/New_York' });

  jobs.set(msg.id, job);
}

// Re-register jobs on startup
scheduledMessages.forEach(msg => {
  if (msg.repeat !== 'none' || !isDateTimeInPast(msg.date, msg.time)) {
    scheduleJob(msg);
  }
});

// ================================
// SIMPLIFIED HANDLERS
// ================================

// Entry point
app.command('/pm', async ({ ack, body, client }) => {
  await ack();
  await client.views.open({
    trigger_id: body.trigger_id,
    view: createModal('menu')
  });
});

// Form element handlers (just update state)
app.action('date_picker', async ({ ack, body }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.date = body.actions[0].selected_date;
  data.scheduleType = 'schedule';
  formData.set(userId, data);
});

app.action('time_picker', async ({ ack, body }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.time = body.actions[0].selected_time;
  data.scheduleType = 'schedule';
  formData.set(userId, data);
});

app.action('channel_select', async ({ ack, body }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.channel = body.actions[0].selected_conversation;
  formData.set(userId, data);
});

app.action('alert_channels_select', async ({ ack, body }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.alertChannels = body.actions[0].selected_conversations || [];
  formData.set(userId, data);
});

app.action('repeat_select', async ({ ack, body }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.repeat = body.actions[0].selected_option.value;
  formData.set(userId, data);
});

// Timing buttons (update state + refresh modal)
app.action('timing_now', async ({ ack, body, client }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.scheduleType = 'now';
  formData.set(userId, data);

  await client.views.update({
    view_id: body.view.id,
    view: createModal('schedule', data)
  });
});

app.action('timing_schedule', async ({ ack, body, client }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.scheduleType = 'schedule';
  if (!data.date) data.date = todayInEST();
  if (!data.time) data.time = '09:00';
  formData.set(userId, data);

  await client.views.update({
    view_id: body.view.id,
    view: createModal('schedule', data)
  });
});

// Navigation handlers
const pages = ['nav_menu', 'nav_scheduled', 'nav_preview', 'nav_schedule'];
pages.forEach(action => {
  app.action(action, async ({ ack, body, client }) => {
    await ack();
    const page = action.replace('nav_', '');
    const userId = body.user.id;
    const data = formData.get(userId) || {};

    await client.views.update({
      view_id: body.view.id,
      view: createModal(page, data)
    });
  });
});

// Message type handlers (reset data for new type)
const messageTypes = ['nav_capacity', 'nav_poll', 'nav_help', 'nav_custom'];
messageTypes.forEach(action => {
  app.action(action, async ({ ack, body, client }) => {
    await ack();
    const messageType = action.replace('nav_', '');
    const userId = body.user.id;

    // Reset data for new message type
    let data = { type: messageType, scheduleType: 'schedule' };

    if (messageType === 'capacity') {
      data.text = templates.capacity;
    } else if (messageType === 'help') {
      data.text = templates.help;
      data.alertChannels = [];
    } else if (messageType === 'poll') {
      data.title = '';
      data.text = '';
      data.pollType = 'single';
      data.pollOptions = 'Option 1\nOption 2';
    } else if (messageType === 'custom') {
      data.title = '';
      data.text = '';
    }

    formData.set(userId, data);

    await client.views.update({
      view_id: body.view.id,
      view: createModal(messageType, data)
    });
  });
});

// Poll interactive handlers
app.action('poll_type_radio', async ({ ack, body, client }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};
  data.pollType = body.actions[0].selected_option.value;
  
  if (data.pollType === 'open') {
    data.pollOptions = '';
  }
  
  formData.set(userId, data);

  await client.views.update({
    view_id: body.view.id,
    view: createModal('poll', data)
  });
});

app.action('add_poll_option', async ({ ack, body, client }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};

  // Extract current options
  const values = body.view.state.values;
  let options = [];
  let index = 0;
  while (values[`option_${index}_block`]) {
    const optionValue = values[`option_${index}_block`][`option_${index}_input`]?.value?.trim();
    if (optionValue) options.push(optionValue);
    index++;
  }

  if (options.length < 10) {
    options.push(`Option ${options.length + 1}`);
    data.pollOptions = options.join('\n');
    formData.set(userId, data);
  }

  await client.views.update({
    view_id: body.view.id,
    view: createModal('poll', data)
  });
});

app.action('remove_poll_option', async ({ ack, body, client }) => {
  await ack();
  const userId = body.user.id;
  const data = formData.get(userId) || {};

  const values = body.view.state.values;
  let options = [];
  let index = 0;
  while (values[`option_${index}_block`]) {
    const optionValue = values[`option_${index}_block`][`option_${index}_input`]?.value?.trim();
    if (optionValue) options.push(optionValue);
    index++;
  }

  if (options.length > 2) {
    options.pop();
    data.pollOptions = options.join('\n');
    formData.set(userId, data);
  }

  await client.views.update({
    view_id: body.view.id,
    view: createModal('poll', data)
  });
});

// Form submission handler (extract final form data and process)
app.view('scheduler_schedule', async ({ ack, body, view, client }) => {
  await ack();
  
  const userId = body.user.id;
  let data = formData.get(userId) || {};
  const values = view.state.values;

  console.log('Schedule submission received');

  // Extract final form values
  data.channel = values.channel_block?.channel_select?.selected_conversation || data.channel;
  
  if (data.type === 'help') {
    data.alertChannels = values.alert_channels_block?.alert_channels_select?.selected_conversations || data.alertChannels || [];
  }

  // Extract schedule data if scheduling
  const hasDateTimeFields = values.datetime_block?.date_picker || values.datetime_block?.time_picker;
  if (data.scheduleType === 'schedule' || hasDateTimeFields) {
    data.date = values.datetime_block?.date_picker?.selected_date || data.date || todayInEST();
    data.time = values.datetime_block?.time_picker?.selected_time || data.time || '09:00';
    data.repeat = values.repeat_block?.repeat_select?.selected_option?.value || data.repeat || 'none';
    
    if (hasDateTimeFields) data.scheduleType = 'schedule';
  }

  console.log('Final data:', { type: data.type, channel: data.channel, scheduleType: data.scheduleType, date: data.date, time: data.time });

  // Validation
  if (!data.channel) {
    await client.chat.postEphemeral({
      channel: body.user.id,
      user: userId,
      text: 'Please select a channel first.'
    });
    return;
  }

  if (data.type === 'help' && (!data.alertChannels || data.alertChannels.length === 0)) {
    await client.chat.postEphemeral({
      channel: body.user.id,
      user: userId,
      text: 'Please select at least one alert channel for help notifications.'
    });
    return;
  }

  // Generate ID
  if (!data.id) data.id = generateId();

  // Process message
  if (data.scheduleType === 'now') {
    const success = await sendMessage(data);
    await client.chat.postEphemeral({
      channel: body.user.id,
      user: userId,
      text: success ? 
        `${data.type} message posted to <#${data.channel}>!${cat()}` :
        `Failed to post message. Please check that I'm invited to <#${data.channel}>.${cat()}`
    });
  } else {
    // Validate future time
    if (data.repeat === 'none' && isDateTimeInPast(data.date, data.time)) {
      await client.chat.postEphemeral({
        channel: body.user.id,
        user: userId,
        text: 'Cannot schedule messages in the past.'
      });
      return;
    }

    scheduledMessages.push(data);
    saveMessages();
    scheduleJob(data);

    await client.chat.postEphemeral({
      channel: body.user.id,
      user: userId,
      text: `${data.type} message scheduled for <#${data.channel}>!${cat()}\n${data.date} at ${formatTimeDisplay(data.time)}\nRepeat: ${data.repeat !== 'none' ? data.repeat : 'One-time'}`
    });

    console.log('Message scheduled successfully');
  }

  // Clear form data
  formData.delete(userId);
});

// Delete scheduled message
app.action(/^delete_message_.+/, async ({ ack, body, client, action }) => {
  await ack();
  const msgId = action.value;

  scheduledMessages = scheduledMessages.filter(msg => msg.id !== msgId);

  if (jobs.has(msgId)) {
    try { jobs.get(msgId).destroy(); } catch (_) {}
    jobs.delete(msgId);
  }

  saveMessages();

  await client.views.update({
    view_id: body.view.id,
    view: createModal('scheduled')
  });

  console.log(`Scheduled message ${msgId} deleted`);
});

// Poll voting
app.action(/^poll_vote_.+/, async ({ ack, body, client, action }) => {
  await ack();
  
  const [, , msgId, optionId] = action.action_id.split('_');
  const user = body.user.id;

  if (!pollVotes[msgId]) pollVotes[msgId] = {};

  const msg = scheduledMessages.find(m => m.id === msgId);
  if (!msg) return;

  const options = (msg.pollOptions || '').split('\n').filter(Boolean);

  // Initialize vote tracking
  for (let i = 0; i < options.length; i++) {
    if (!pollVotes[msgId][i]) pollVotes[msgId][i] = new Set();
  }

  const pollType = msg.pollType || 'single';

  if (pollType === 'single') {
    // Remove from all options, add to selected
    Object.values(pollVotes[msgId]).forEach(set => set.delete(user));
    pollVotes[msgId][optionId].add(user);
  } else if (pollType === 'multiple') {
    // Toggle vote for this option
    if (pollVotes[msgId][optionId].has(user)) {
      pollVotes[msgId][optionId].delete(user);
    } else {
      pollVotes[msgId][optionId].add(user);
    }
  }

  await client.chat.postEphemeral({
    channel: body.channel.id,
    user: user,
    text: `Vote recorded${cat()}`
  });
});

// Help button clicks
app.action(/^help_click_.+/, async ({ ack, body, client, action }) => {
  await ack();
  
  const actionData = JSON.parse(action.value);
  const alertChannels = actionData.alertChannels || [];
  const user = body.user.id;
  const channel = body.channel.id;

  if (!alertChannels.length) {
    await client.chat.postEphemeral({
      channel, user,
      text: 'No alert channels configured for this help button.'
    });
    return;
  }

  let successCount = 0;
  const alertPromises = alertChannels.map(async (alertChannel) => {
    try {
      await client.chat.postMessage({
        channel: alertChannel,
        text: `üÜò <@${user}> needs backup in <#${channel}>`,
        unfurl_links: false,
        unfurl_media: false
      });
      successCount++;
    } catch (e) {
      console.error(`Alert failed for channel ${alertChannel}:`, e);
    }
  });

  await Promise.all(alertPromises);

  await client.chat.postEphemeral({
    channel, user,
    text: `Backup request sent to ${successCount}/${alertChannels.length} alert channels.${cat()}`
  });

  if (successCount > 0) {
    await client.chat.postMessage({
      channel,
      text: `üö® <@${user}> has requested backup!${cat()}`
    });
  }
});

// Global error handler
app.error((error) => {
  console.error('Global error:', error);
});

// Cleanup expired messages hourly
cron.schedule('0 * * * *', () => {
  const beforeCount = scheduledMessages.length;
  scheduledMessages = scheduledMessages.filter(msg => {
    if (msg.repeat !== 'none') return true;

    const isPast = isDateTimeInPast(msg.date, msg.time);
    if (isPast && jobs.has(msg.id)) {
      try { jobs.get(msg.id).destroy(); } catch (_) {}
      jobs.delete(msg.id);
    }
    return !isPast;
  });

  if (scheduledMessages.length !== beforeCount) {
    saveMessages();
    console.log(`Cleaned up ${beforeCount - scheduledMessages.length} expired messages`);
  }
}, { timezone: 'America/New_York' });

// ================================
// STARTUP
// ================================

(async () => {
  try {
    await app.start();
    console.log('PM Squad Bot is running! (CLEANED VERSION)');
    console.log(`Loaded ${scheduledMessages.length} scheduled messages`);
    console.log(`Active jobs: ${jobs.size}`);
    console.log('Use /pm to start');
  } catch (error) {
    console.error('Failed to start app:', error);
    process.exit(1);
  }
})();

process.on('SIGINT', () => {
  console.log('Shutting down gracefully...');
  jobs.forEach(job => job.destroy());
  process.exit(0);
});
